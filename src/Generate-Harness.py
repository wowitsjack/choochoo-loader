#!/usr/bin/env python3
"""
AUTOGENERATED BY STUPIDBOY VSCODE DEPLOYMENT WRAPPER

Usage:
  python genbin.py
"""

import os
import sys
import subprocess
import time

def write_file(filename: str, content: str) -> None:
    print(f"Writing {filename} ...")
    with open(filename, "w", encoding="utf-8") as f:
        f.write(content)
    print(f"... done with {filename}\n")

def main() -> None:
    files = {
"ChooChooApp.csproj": r"""<Project Sdk="Microsoft.NET.Sdk.WindowsDesktop">
  <PropertyGroup>
    <!-- WinForms project targeting net48 for Wine Mono -->
    <UseWindowsForms>true</UseWindowsForms>
    <OutputType>WinExe</OutputType>
    <TargetFramework>net48</TargetFramework>
    <AssemblyName>ChooChoo</AssemblyName>
    <ApplicationIcon>icon.ico</ApplicationIcon>
    <LangVersion>8.0</LangVersion>
  </PropertyGroup>
  <ItemGroup>
    <None Include="Fonts\MotivaSans.ttf" CopyToOutputDirectory="Always" />
  </ItemGroup>
</Project>
""",
"ChooChooApp.csproj.user": r"""<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <!-- No explicit Compile items are included since the SDK now includes all source files by default. -->
</Project>
""",
"HelpTab.cs": r"""using System;
using System.Drawing;
using System.Windows.Forms;

namespace ChooChooApp
{
    // A simple help tab.
    public class HelpTab : UserControl
    {
        public HelpTab()
        {
            InitializeComponent();
            this.KeyDown += HelpTab_KeyDown;
            this.SetStyle(ControlStyles.Selectable, true);
            this.TabStop = true;
        }
        private void InitializeComponent()
        {
            this.Dock = DockStyle.Fill;
            RichTextBox rtb = new RichTextBox()
            {
                Dock = DockStyle.Fill,
                ReadOnly = true,
                BackColor = Color.FromArgb(30,30,30),
                ForeColor = Color.White,
                Font = new Font("Tahoma", 11),
                BorderStyle = BorderStyle.None
            };
            rtb.Text =
@"=======================================
         CHOOCHOO INJECTION ENGINE
               HELP GUIDE

Overview
--------
Launch your game/trainer and use our advanced tools for process
manipulation. Features include:
 • Fullscreen mode for uninterrupted XInput.
 • Smart detection of running game processes.
 • DLL injection into the target process.
 • State saving and restoring.
 • A full suite of tools for freeze, dump, list imports/runtimes, etc.

That's it.
";
            rtb.KeyDown += HelpTab_KeyDown;
            rtb.TabStop = true;
            this.Controls.Add(rtb);
        }
        private void HelpTab_KeyDown(object sender, KeyEventArgs e)
        {
            // No special key handling.
        }
    }
}
""",
"ProcessHelper.cs": r"""using System;
using System.Collections.Generic;
using System.Diagnostics;

namespace ChooChooApp
{
    public static class ProcessHelper
    {
        // Under Wine, Process.GetProcesses() works reliably.
        // We filter by nonempty MainWindowTitle.
        public static Process[] GetProcesses()
        {
            try
            {
                Process[] all = Process.GetProcesses();
                List<Process> list = new List<Process>();
                foreach (Process p in all)
                {
                    try { if (!string.IsNullOrEmpty(p.MainWindowTitle)) list.Add(p); } catch { }
                }
                return list.ToArray();
            }
            catch { return new Process[0]; }
        }
    }
}
""",
"GlobalHook.cs": r"""using System;
using System.Drawing;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Windows.Forms;

namespace ChooChooApp
{
    public class GlobalHook : IDisposable
    {
        private const int WH_KEYBOARD_LL = 13;
        private IntPtr hookId = IntPtr.Zero;
        private HookProc proc;

        public event EventHandler<GlobalHookEventArgs> KeyPressed;

        public GlobalHook()
        {
            proc = HookCallback;
            hookId = SetHook(proc);
        }

        private IntPtr SetHook(HookProc proc)
        {
            using (Process curProcess = Process.GetCurrentProcess())
            using (ProcessModule curModule = curProcess.MainModule)
            {
                return SetWindowsHookEx(WH_KEYBOARD_LL, proc, GetModuleHandle(curModule.ModuleName), 0);
            }
        }

        private delegate IntPtr HookProc(int nCode, IntPtr wParam, IntPtr lParam);

        private IntPtr HookCallback(int nCode, IntPtr wParam, IntPtr lParam)
        {
            if (nCode >= 0)
            {
                int msg = wParam.ToInt32();
                const int WM_KEYDOWN = 0x0100;
                const int WM_SYSKEYDOWN = 0x0104;
                if (msg == WM_KEYDOWN || msg == WM_SYSKEYDOWN)
                {
                    KBDLLHOOKSTRUCT hookStruct = Marshal.PtrToStructure<KBDLLHOOKSTRUCT>(lParam);
                    Keys key = (Keys)hookStruct.vkCode;
                    OnKeyPressed(new GlobalHookEventArgs(key));
                }
            }
            return CallNextHookEx(hookId, nCode, wParam, lParam);
        }

        protected virtual void OnKeyPressed(GlobalHookEventArgs e)
        {
            KeyPressed?.Invoke(this, e);
        }

        public void Dispose()
        {
            UnhookWindowsHookEx(hookId);
        }

        [StructLayout(LayoutKind.Sequential)]
        private struct KBDLLHOOKSTRUCT
        {
            public uint vkCode;
            public uint scanCode;
            public uint flags;
            public uint time;
            public IntPtr dwExtraInfo;
        }

        [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        private static extern IntPtr SetWindowsHookEx(int idHook, HookProc lpfn, IntPtr hMod, uint dwThreadId);

        [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        private static extern bool UnhookWindowsHookEx(IntPtr hhk);

        [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        private static extern IntPtr CallNextHookEx(IntPtr hhk, int nCode, IntPtr wParam, IntPtr lParam);

        [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        private static extern IntPtr GetModuleHandle(string lpModuleName);
    }

    public class GlobalHookEventArgs : EventArgs
    {
        public Keys Key { get; private set; }
        public GlobalHookEventArgs(Keys key)
        {
            Key = key;
        }
    }
}
""",
"GlobalMouseHook.cs": r"""using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Windows.Forms;
using System.Drawing;

namespace ChooChooApp
{
    public class GlobalMouseHook : IDisposable
    {
        private const int WH_MOUSE_LL = 14;
        private IntPtr hookId = IntPtr.Zero;
        private HookProc proc;

        public event EventHandler<GlobalMouseHookEventArgs> MouseAction;

        public GlobalMouseHook()
        {
            proc = HookCallback;
            hookId = SetHook(proc);
        }

        private IntPtr SetHook(HookProc proc)
        {
            using (Process curProcess = Process.GetCurrentProcess())
            using (ProcessModule curModule = curProcess.MainModule)
            {
                return SetWindowsHookEx(WH_MOUSE_LL, proc, GetModuleHandle(curModule.ModuleName), 0);
            }
        }

        private delegate IntPtr HookProc(int nCode, IntPtr wParam, IntPtr lParam);

        private IntPtr HookCallback(int nCode, IntPtr wParam, IntPtr lParam)
        {
            if (nCode >= 0)
            {
                MSLLHOOKSTRUCT hookStruct = Marshal.PtrToStructure<MSLLHOOKSTRUCT>(lParam);
                MouseMessages message = (MouseMessages)wParam.ToInt32();
                OnMouseAction(new GlobalMouseHookEventArgs(message, new Point(hookStruct.pt.x, hookStruct.pt.y)));
            }
            return CallNextHookEx(hookId, nCode, wParam, lParam);
        }

        protected virtual void OnMouseAction(GlobalMouseHookEventArgs e)
        {
            MouseAction?.Invoke(this, e);
        }

        public void Dispose()
        {
            UnhookWindowsHookEx(hookId);
        }

        [StructLayout(LayoutKind.Sequential)]
        private struct POINT
        {
            public int x;
            public int y;
        }

        [StructLayout(LayoutKind.Sequential)]
        private struct MSLLHOOKSTRUCT
        {
            public POINT pt;
            public uint mouseData;
            public uint flags;
            public uint time;
            public IntPtr dwExtraInfo;
        }

        public enum MouseMessages
        {
            WM_MOUSEMOVE = 0x200,
            WM_LBUTTONDOWN = 0x201,
            WM_LBUTTONUP = 0x202,
            WM_RBUTTONDOWN = 0x204,
            WM_RBUTTONUP = 0x205,
            WM_MOUSEWHEEL = 0x20A
        }

        [DllImport("user32.dll", CharSet=CharSet.Auto, SetLastError=true)]
        private static extern IntPtr SetWindowsHookEx(int idHook, HookProc lpfn, IntPtr hMod, uint dwThreadId);

        [DllImport("user32.dll", CharSet=CharSet.Auto, SetLastError=true)]
        private static extern bool UnhookWindowsHookEx(IntPtr hhk);

        [DllImport("user32.dll", CharSet=CharSet.Auto, SetLastError=true)]
        private static extern IntPtr CallNextHookEx(IntPtr hhk, int nCode, IntPtr wParam, IntPtr lParam);

        [DllImport("kernel32.dll", CharSet=CharSet.Auto, SetLastError=true)]
        private static extern IntPtr GetModuleHandle(string lpModuleName);
    }

    public class GlobalMouseHookEventArgs : EventArgs
    {
        public GlobalMouseHook.MouseMessages Message { get; private set; }
        public Point Location { get; private set; }
        public GlobalMouseHookEventArgs(GlobalMouseHook.MouseMessages message, Point location)
        {
            Message = message;
            Location = location;
        }
    }
}
""",
"Program.cs": r"""using System;
using System.Drawing;
using System.Drawing.Text;
using System.Windows.Forms;
using System.IO;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using Microsoft.Win32;
using WinFormsTimer = System.Windows.Forms.Timer;
using System.Linq;

namespace ChooChooApp
{
    // A simple input box for TV mode.
    public static class SimpleInputBox
    {
        public static string Show(string prompt, string title, string defaultValue)
        {
            return defaultValue;
        }
    }

    // XInput definitions.
    public static class XInputConstants
    {
        public const ushort XINPUT_GAMEPAD_DPAD_UP = 0x0001;
        public const ushort XINPUT_GAMEPAD_DPAD_DOWN = 0x0002;
        public const ushort XINPUT_GAMEPAD_DPAD_LEFT = 0x0004;
        public const ushort XINPUT_GAMEPAD_DPAD_RIGHT = 0x0008;
        public const ushort XINPUT_GAMEPAD_START = 0x0010;
        public const ushort XINPUT_GAMEPAD_BACK = 0x0020;
        public const ushort XINPUT_GAMEPAD_LEFT_THUMB = 0x0040;
        public const ushort XINPUT_GAMEPAD_RIGHT_THUMB = 0x0080;
        public const ushort XINPUT_GAMEPAD_LEFT_SHOULDER = 0x0100;
        public const ushort XINPUT_GAMEPAD_RIGHT_SHOULDER = 0x0200;
        public const ushort XINPUT_GAMEPAD_A = 0x1000;
        public const ushort XINPUT_GAMEPAD_B = 0x2000;
        public const ushort XINPUT_GAMEPAD_X = 0x4000;
        public const ushort XINPUT_GAMEPAD_Y = 0x8000;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct XINPUT_GAMEPAD
    {
        public ushort wButtons;
        public byte bLeftTrigger;
        public byte bRightTrigger;
        public short sThumbLX;
        public short sThumbLY;
        public short sThumbRX;
        public short sThumbRY;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct XINPUT_STATE
    {
        public uint dwPacketNumber;
        public XINPUT_GAMEPAD Gamepad;
    }

    public static class XInput
    {
        [DllImport("xinput1_4.dll")]
        public static extern uint XInputGetState(uint dwUserIndex, out XINPUT_STATE pState);
    }

    // Minidump and native methods.
    public enum MINIDUMP_TYPE : uint
    {
        MiniDumpNormal = 0x00000000,
        MiniDumpWithDataSegs = 0x00000001,
        MiniDumpWithFullMemory = 0x00000002
    }

    public static class NativeMethods
    {
        public const uint MEM_COMMIT = 0x1000;
        public const uint MEM_RESERVE = 0x2000;
        public const uint PAGE_READWRITE = 0x04;
        public const uint MEM_RELEASE = 0x8000;
        public const uint INFINITE = 0xFFFFFFFF;
        public const uint THREAD_SUSPEND_RESUME = 0x0002;

        [DllImport("dbghelp.dll", SetLastError = true)]
        public static extern bool MiniDumpWriteDump(
            IntPtr hProcess,
            uint ProcessId,
            IntPtr hFile,
            MINIDUMP_TYPE DumpType,
            IntPtr ExceptionParam,
            IntPtr UserStreamParam,
            IntPtr CallbackParam);

        [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern bool VirtualFreeEx(IntPtr hProcess, IntPtr lpAddress, uint dwSize, uint dwFreeType);

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] buffer, uint nSize, out UIntPtr lpNumberOfBytesWritten);

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern bool ReadProcessMemory(IntPtr hProcess, IntPtr lpAddress, [Out] byte[] lpBuffer, uint dwSize, out UIntPtr lpNumberOfBytesRead);

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttributes, uint dwStackSize,
            IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, out uint lpThreadId);

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern uint WaitForSingleObject(IntPtr hHandle, uint dwMilliseconds);

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern bool CloseHandle(IntPtr hObject);

        [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern IntPtr GetModuleHandle(string lpModuleName);

        [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Ansi)]
        public static extern IntPtr GetProcAddress(IntPtr hModule, string procName);

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern IntPtr OpenThread(uint dwDesiredAccess, bool bInheritHandle, uint dwThreadId);

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern uint SuspendThread(IntPtr hThread);

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern int ResumeThread(IntPtr hThread);

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern IntPtr VirtualQueryEx(IntPtr hProcess, IntPtr lpAddress, out MEMORY_BASIC_INFORMATION lpBuffer, uint dwLength);
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct MEMORY_BASIC_INFORMATION
    {
        public IntPtr BaseAddress;
        public IntPtr AllocationBase;
        public uint AllocationProtect;
        public IntPtr RegionSize;
        public uint State;
        public uint Protect;
        public uint Type;
    }

    public static class Win32API
    {
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
        public struct STARTUPINFO
        {
            public int cb;
            public string lpReserved;
            public string lpDesktop;
            public string lpTitle;
            public int dwX;
            public int dwY;
            public int dwXSize;
            public int dwYSize;
            public int dwXCountChars;
            public int dwYCountChars;
            public int dwFillAttribute;
            public int dwFlags;
            public short wShowWindow;
            public short cbReserved2;
            public IntPtr lpReserved2;
            public IntPtr hStdInput;
            public IntPtr hStdOutput;
            public IntPtr hStdError;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct PROCESS_INFORMATION
        {
            public IntPtr hProcess;
            public IntPtr hThread;
            public int dwProcessId;
            public int dwThreadId;
        }

        [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Auto)]
        public static extern bool CreateProcess(
            string lpApplicationName,
            string lpCommandLine,
            IntPtr lpProcessAttributes,
            IntPtr lpThreadAttributes,
            bool bInheritHandles,
            uint dwCreationFlags,
            IntPtr lpEnvironment,
            string lpCurrentDirectory,
            ref STARTUPINFO lpStartupInfo,
            out PROCESS_INFORMATION lpProcessInformation);
    }

    public partial class MainForm : Form
    {
        // Field declarations
        private Panel overlayPanel;
        private Font tvFont;
        private Panel mainPanel;
        private TabControl tabControl;
        private TabPage tabPageMain, tabPageHelp, tabPageTools;
        private CheckBox chkFullscreen, chkTVMode, chkAutoLaunch;
        private GroupBox groupPaths, groupProfiles;
        private Label labelRunningExes, labelGamePath, labelTrainerPath;
        private ComboBox comboRunningExes, comboGame, comboTrainer, comboProfiles;
        private Button btnBrowseGame, btnBrowseTrainer;
        private Button btnRefreshProfiles, btnLoadProfile, btnSaveProfile, btnDeleteProfile;
        private CheckBox[] chkAdditional = new CheckBox[4];
        private ComboBox[] comboAdditional = new ComboBox[4];
        private Button[] btnBrowseAdditional = new Button[4];
        private TextBox txtStatusLog, txtToolOutput;
        private ListBox listBoxDlls;
        private Button btnLaunch;
        // New group for trainer launch methods
        private GroupBox groupTrainerMethods;
        private FlowLayoutPanel flpTrainerMethods;
        private RadioButton[] radioTrainerMethods = new RadioButton[6];
        // TV Mode controls
        private Panel tvModePanel;
        private ListView tvModeList;
        private TextBox tvInfoText;
        // File Browser controls
        private Panel fileBrowserPanel;
        private TableLayoutPanel fileBrowserLayout;
        private TextBox fileBrowserPathEntry;
        private ListView fileBrowserList;
        private FlowLayoutPanel fileBrowserButtonPanel;
        private Button btnUp, btnRefresh, btnSelect, btnCancel;
        private Control currentTargetControl;
        private string currentDirectory;
        // Other fields
        private string recentFile = "recent.ini";
        private string profilesDir = "profiles";
        private string settingsFile = "settings.ini";
        private Process gameProcess;
        // XInput tracking
        private XINPUT_STATE prevXInputState;
        private byte prevLeftTrigger, prevRightTrigger;
        // Arrow animation
        private double arrowAnimationTime;
        private int arrowAnimationOffset;
        private int arrowAnimationAmplitude = 3;
        private double arrowAnimationPeriod = 3.0;
        // Declare arrowAnimationTimer as a field
        private WinFormsTimer arrowAnimationTimer;
        // DLL injection validation
        private string[] additionalInjectedFile = new string[4];
        private Dictionary<string, bool> validatedDlls = new Dictionary<string, bool>();
        // Analog sent flags
        private bool analogDownSent, analogUpSent, analogLeftSent, analogRightSent;
        // Global hooks
        private GlobalHook globalHook;
        private GlobalMouseHook globalMouseHook;
        // Custom cursor and active element indicator
        private Cursor myCursor;
        private Label arrowIndicator;

        protected override CreateParams CreateParams
        {
            get {
                CreateParams cp = base.CreateParams;
                cp.ExStyle |= 0x00040000;
                return cp;
            }
        }

        [DllImport("user32.dll")]
        private static extern bool ReleaseCapture();

        private void OverlayPanel_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.KeyCode == Keys.Escape)
            {
                HideOverlay();
                e.Handled = true;
            }
        }

        protected override void OnActivated(EventArgs e)
        {
            base.OnActivated(e);
            ReleaseCapture();
            Cursor.Clip = Rectangle.Empty;
            Cursor.Current = myCursor;
            Cursor.Show();
        }

        protected override void WndProc(ref Message m)
        {
            const int WM_SETCURSOR = 0x20;
            const int WM_MOUSEACTIVATE = 0x21;
            if (m.Msg == WM_SETCURSOR)
            {
                Cursor.Current = myCursor;
                m.Result = new IntPtr(1);
                return;
            }
            else if (m.Msg == WM_MOUSEACTIVATE)
            {
                m.Result = new IntPtr(1);
                return;
            }
            base.WndProc(ref m);
        }

        public MainForm()
        {
            this.Text = "ChooChoo Injection Engine - Standalone";
            this.ShowInTaskbar = true;
            this.Owner = null;
            this.Font = new Font("Tahoma", 9);
            this.ForeColor = Color.White;
            this.ClientSize = new Size(1200,750);
            this.FormBorderStyle = FormBorderStyle.FixedDialog;
            this.MaximizeBox = false;
            this.StartPosition = FormStartPosition.CenterScreen;

            try { myCursor = new Cursor("cursor.cur"); } catch { myCursor = Cursors.Default; }

            Directory.CreateDirectory(profilesDir);
            overlayPanel = new Panel();
            overlayPanel.Dock = DockStyle.Fill;
            overlayPanel.BackColor = Color.FromArgb(60,60,60);
            overlayPanel.Visible = false;
            overlayPanel.KeyDown += OverlayPanel_KeyDown;
            this.Controls.Add(overlayPanel);
            overlayPanel.BringToFront();

            string startupPath = Application.StartupPath;
            try {
                PrivateFontCollection pfc = new PrivateFontCollection();
                string fontPath = Path.Combine(startupPath, "Fonts", "MotivaSans.ttf");
                pfc.AddFontFile(fontPath);
                tvFont = new Font(pfc.Families[0], 24, FontStyle.Bold);
            } catch {
                tvFont = new Font("Tahoma", 24, FontStyle.Bold);
            }

            SetupFileBrowserPanel();
            SetupTVModePanel();

            mainPanel = new Panel() { Dock = DockStyle.Fill };
            this.Controls.Add(mainPanel);
            tabControl = new TabControl() { Dock = DockStyle.Fill, ForeColor = Color.White };
            tabControl.ItemSize = new Size(100, 25);
            tabControl.SizeMode = TabSizeMode.Fixed;
            mainPanel.Controls.Add(tabControl);
            tabPageMain = new TabPage("Main") { ForeColor = Color.White };
            tabPageHelp = new TabPage("Help") { ForeColor = Color.White };
            tabPageTools = new TabPage("Tools") { ForeColor = Color.White };
            tabControl.TabPages.Add(tabPageMain);
            tabControl.TabPages.Add(tabPageHelp);
            tabControl.TabPages.Add(tabPageTools);

            Panel mainTabPanel = new Panel() { Dock = DockStyle.Fill };
            tabPageMain.Controls.Add(mainTabPanel);

            chkFullscreen = new CheckBox() { Text = "Fullscreen Mode", Location = new Point(10,10), AutoSize = true, ForeColor = Color.White };
            mainTabPanel.Controls.Add(chkFullscreen);

            chkTVMode = new CheckBox() { Text = "TV Mode", Location = new Point(150,10), AutoSize = true, ForeColor = Color.White };
            chkTVMode.CheckedChanged += (s,e) => ToggleTVMode();
            mainTabPanel.Controls.Add(chkTVMode);

            groupPaths = new GroupBox() { Text = "Paths & Process Selection", Bounds = new Rectangle(10,40,850,320), ForeColor = Color.White, BackColor = Color.FromArgb(45,45,48) };
            mainTabPanel.Controls.Add(groupPaths);

            labelRunningExes = new Label() { Text = "Running Exe (Optional):", Location = new Point(20,25), AutoSize = true, ForeColor = Color.White };
            groupPaths.Controls.Add(labelRunningExes);

            comboRunningExes = new ComboBox() { Location = new Point(200,20), Size = new Size(500,25), DropDownStyle = ComboBoxStyle.DropDownList, ForeColor = Color.White };
            comboRunningExes.DrawMode = DrawMode.OwnerDrawFixed;
            comboRunningExes.DrawItem += (s, e) =>
            {
                e.DrawBackground();
                if (e.Index >= 0)
                {
                    Process proc = comboRunningExes.Items[e.Index] as Process;
                    string text = proc != null ? $"{proc.ProcessName} (PID {proc.Id})" : "";
                    SizeF textSize = e.Graphics.MeasureString(text, comboRunningExes.Font);
                    float x = e.Bounds.Left + (e.Bounds.Width - textSize.Width) / 2;
                    float y = e.Bounds.Top + (e.Bounds.Height - textSize.Height) / 2;
                    using (SolidBrush brush = new SolidBrush(e.ForeColor))
                    {
                        e.Graphics.DrawString(text, comboRunningExes.Font, brush, x, y);
                    }
                }
                e.DrawFocusRectangle();
            };
            groupPaths.Controls.Add(comboRunningExes);
            comboRunningExes.SelectedIndexChanged += (s,e) =>
            {
                if (comboRunningExes.SelectedItem is Process proc)
                {
                    gameProcess = proc;
                    LogStatus("Process selected: " + proc.ProcessName + " (PID " + proc.Id + ")");
                }
            };

            labelGamePath = new Label() { Text = "Game Path (Optional):", Location = new Point(20,65), AutoSize = true, ForeColor = Color.White };
            groupPaths.Controls.Add(labelGamePath);

            comboGame = new ComboBox() { Location = new Point(200,60), Size = new Size(430,25), DropDownStyle = ComboBoxStyle.DropDown, ForeColor = Color.White };
            groupPaths.Controls.Add(comboGame);

            btnBrowseGame = new Button() { Text = "Browse...", Location = new Point(640,60), Size = new Size(100,25), ForeColor = Color.White, BackColor = Color.FromArgb(70,70,70) };
            btnBrowseGame.Click += (s,e) => IntegratedBrowse(comboGame);
            groupPaths.Controls.Add(btnBrowseGame);

            labelTrainerPath = new Label() { Text = "Trainer Path:", Location = new Point(20,105), AutoSize = true, ForeColor = Color.White };
            groupPaths.Controls.Add(labelTrainerPath);

            comboTrainer = new ComboBox() { Location = new Point(130,100), Size = new Size(500,25), DropDownStyle = ComboBoxStyle.DropDown, ForeColor = Color.White };
            groupPaths.Controls.Add(comboTrainer);

            btnBrowseTrainer = new Button() { Text = "Browse...", Location = new Point(640,100), Size = new Size(100,25), ForeColor = Color.White, BackColor = Color.FromArgb(70,70,70) };
            btnBrowseTrainer.Click += (s,e) => IntegratedBrowse(comboTrainer);
            groupPaths.Controls.Add(btnBrowseTrainer);

            for (int i = 0; i < 4; i++)
            {
                int y = 145 + i * 35;
                chkAdditional[i] = new CheckBox() { Text = "Launch/Inject (Optional)", Location = new Point(20,y), ForeColor = Color.White };
                groupPaths.Controls.Add(chkAdditional[i]);
                comboAdditional[i] = new ComboBox() { Location = new Point(130,y), Size = new Size(500,25), DropDownStyle = ComboBoxStyle.DropDown, ForeColor = Color.White };
                groupPaths.Controls.Add(comboAdditional[i]);
                btnBrowseAdditional[i] = new Button() { Text = "Browse...", Location = new Point(640,y), Size = new Size(100,25), ForeColor = Color.White, BackColor = Color.FromArgb(70,70,70) };
                int idxLocal = i;
                btnBrowseAdditional[i].Click += (s,e) => IntegratedBrowse(comboAdditional[idxLocal]);
                groupPaths.Controls.Add(btnBrowseAdditional[i]);
            }

            chkAutoLaunch = new CheckBox() { Text = "Save Settings & Enable Autolaunch", Location = new Point(10,groupPaths.Bottom+10), AutoSize = true, ForeColor = Color.White };
            mainTabPanel.Controls.Add(chkAutoLaunch);

            groupProfiles = new GroupBox() { Text = "Profiles", Bounds = new Rectangle(870,40,300,300), ForeColor = Color.White, BackColor = Color.FromArgb(45,45,48) };
            mainTabPanel.Controls.Add(groupProfiles);

            comboProfiles = new ComboBox() { Size = new Size(280,25), Location = new Point((groupProfiles.ClientSize.Width-280)/2,40), DropDownStyle = ComboBoxStyle.DropDown, ForeColor = Color.White };
            groupProfiles.Controls.Add(comboProfiles);

            btnRefreshProfiles = new Button() { Size = new Size(80,30), Location = new Point(65,80), Text = "Refresh", ForeColor = Color.White, BackColor = Color.FromArgb(70,70,70) };
            btnRefreshProfiles.Click += BtnRefreshProfiles_Click;
            groupProfiles.Controls.Add(btnRefreshProfiles);

            btnLoadProfile = new Button() { Size = new Size(80,30), Location = new Point(65+80+10,80), Text = "Load", ForeColor = Color.White, BackColor = Color.FromArgb(70,70,70) };
            btnLoadProfile.Click += BtnLoadProfile_Click;
            groupProfiles.Controls.Add(btnLoadProfile);

            btnSaveProfile = new Button() { Size = new Size(170,30), Location = new Point((groupProfiles.ClientSize.Width-170)/2,120), Text = "Save", ForeColor = Color.White, BackColor = Color.FromArgb(70,70,70) };
            btnSaveProfile.Click += BtnSaveProfile_Click;
            groupProfiles.Controls.Add(btnSaveProfile);

            btnDeleteProfile = new Button() { Size = new Size(170,30), Location = new Point((groupProfiles.ClientSize.Width-170)/2,160), Text = "Delete", ForeColor = Color.White, BackColor = Color.FromArgb(70,70,70) };
            btnDeleteProfile.Click += BtnDeleteProfile_Click;
            groupProfiles.Controls.Add(btnDeleteProfile);

            txtStatusLog = new TextBox() { Multiline = true, ReadOnly = true, ScrollBars = ScrollBars.Vertical, Bounds = new Rectangle(10, chkAutoLaunch.Bottom+10, 850,150), ForeColor = Color.White, BackColor = Color.FromArgb(30,30,30) };
            mainTabPanel.Controls.Add(txtStatusLog);

            listBoxDlls = new ListBox() { Location = new Point(txtStatusLog.Right+10, txtStatusLog.Top), Size = new Size(300,txtStatusLog.Height), BorderStyle = BorderStyle.FixedSingle, Font = new Font("Tahoma",10), ForeColor = Color.White, BackColor = Color.FromArgb(45,45,48) };
            mainTabPanel.Controls.Add(listBoxDlls);

            Panel panelLaunch = new Panel() { Location = new Point(10, txtStatusLog.Bottom+40), Size = new Size(1170,50) };
            mainTabPanel.Controls.Add(panelLaunch);

            btnLaunch = new Button() { Text = "Launch", Size = new Size(panelLaunch.Width, panelLaunch.Height), Location = new Point(0,0), Font = new Font("Tahoma",14,FontStyle.Bold), ForeColor = Color.White, BackColor = Color.FromArgb(70,70,70) };
            btnLaunch.Click += BtnLaunch_Click;
            panelLaunch.Controls.Add(btnLaunch);

            // Trainer launch methods: use a GroupBox with a FlowLayoutPanel for six methods
            groupTrainerMethods = new GroupBox() { Text = "Trainer Launch Methods (Optional)", Bounds = new Rectangle(10, panelLaunch.Bottom+10, 1170, 60), ForeColor = Color.White, BackColor = Color.FromArgb(45,45,48) };
            mainTabPanel.Controls.Add(groupTrainerMethods);
            flpTrainerMethods = new FlowLayoutPanel() { Dock = DockStyle.Fill, FlowDirection = FlowDirection.LeftToRight };
            groupTrainerMethods.Controls.Add(flpTrainerMethods);
            string[] methodNames = { "P/Invoke CreateProcess", "CMD Start", "CreateThread Injection", "Remote Thread Injection", "Shell Execute", "Raw Process.Start" };
            for (int i = 0; i < 6; i++)
            {
                radioTrainerMethods[i] = new RadioButton() { Text = methodNames[i], AutoSize = true, ForeColor = Color.White, BackColor = Color.FromArgb(70,70,70), Margin = new Padding(5) };
                flpTrainerMethods.Controls.Add(radioTrainerMethods[i]);
            }
            radioTrainerMethods[0].Checked = true;

            // Help tab
            HelpTab helpControl = new HelpTab() { Dock = DockStyle.Fill };
            tabPageHelp.Controls.Add(helpControl);

            // Tools tab buttons
            int tbtnWidth = 130, tbtnHeight = 30, tpadding = 10;
            Button btnFreezeProcess = new Button() { Text = "Freeze Proc", Location = new Point(tpadding, tpadding), Size = new Size(tbtnWidth, tbtnHeight), ForeColor = Color.White, BackColor = Color.FromArgb(70,70,70) };
            btnFreezeProcess.Click += BtnFreezeProcess_Click;
            tabPageTools.Controls.Add(btnFreezeProcess);

            Button btnUnfreezeProcess = new Button() { Text = "Unfreeze Proc", Location = new Point(tpadding*2+tbtnWidth, tpadding), Size = new Size(tbtnWidth, tbtnHeight), ForeColor = Color.White, BackColor = Color.FromArgb(70,70,70) };
            btnUnfreezeProcess.Click += BtnUnfreezeProcess_Click;
            tabPageTools.Controls.Add(btnUnfreezeProcess);

            Button btnKillProcess = new Button() { Text = "Kill Proc", Location = new Point(tpadding*3+tbtnWidth*2, tpadding), Size = new Size(tbtnWidth, tbtnHeight), ForeColor = Color.White, BackColor = Color.FromArgb(70,70,70) };
            btnKillProcess.Click += BtnKillProcess_Click;
            tabPageTools.Controls.Add(btnKillProcess);

            Button btnDumpProcess = new Button() { Text = "Dump Proc", Location = new Point(tpadding*4+tbtnWidth*3, tpadding), Size = new Size(tbtnWidth, tbtnHeight), ForeColor = Color.White, BackColor = Color.FromArgb(70,70,70) };
            btnDumpProcess.Click += BtnDumpProcess_Click;
            tabPageTools.Controls.Add(btnDumpProcess);

            Button btnListImports = new Button() { Text = "List Imports", Location = new Point(tpadding*5+tbtnWidth*4, tpadding), Size = new Size(tbtnWidth, tbtnHeight), ForeColor = Color.White, BackColor = Color.FromArgb(70,70,70) };
            btnListImports.Click += BtnListImports_Click;
            tabPageTools.Controls.Add(btnListImports);

            Button btnListRuntimes = new Button() { Text = "List Runtimes", Location = new Point(tpadding, tpadding*2+tbtnHeight), Size = new Size(tbtnWidth, tbtnHeight), ForeColor = Color.White, BackColor = Color.FromArgb(70,70,70) };
            btnListRuntimes.Click += BtnListRuntimes_Click;
            tabPageTools.Controls.Add(btnListRuntimes);

            Button btnSaveState = new Button() { Text = "Save State", Location = new Point(tpadding*2+tbtnWidth, tpadding*2+tbtnHeight), Size = new Size(tbtnWidth, tbtnHeight), ForeColor = Color.White, BackColor = Color.FromArgb(70,70,70) };
            btnSaveState.Click += BtnSaveState_Click;
            tabPageTools.Controls.Add(btnSaveState);

            Button btnLoadState = new Button() { Text = "Load State", Location = new Point(tpadding*3+tbtnWidth*2, tpadding*2+tbtnHeight), Size = new Size(tbtnWidth, tbtnHeight), ForeColor = Color.White, BackColor = Color.FromArgb(70,70,70) };
            btnLoadState.Click += BtnLoadState_Click;
            tabPageTools.Controls.Add(btnLoadState);

            Button btnListModules = new Button() { Text = "List Modules", Location = new Point(tpadding*4+tbtnWidth*3, tpadding*2+tbtnHeight), Size = new Size(tbtnWidth, tbtnHeight), ForeColor = Color.White, BackColor = Color.FromArgb(70,70,70) };
            btnListModules.Click += BtnListModules_Click;
            tabPageTools.Controls.Add(btnListModules);

            Button btnListThreads = new Button() { Text = "List Threads", Location = new Point(tpadding*5+tbtnWidth*4, tpadding*2+tbtnHeight), Size = new Size(tbtnWidth, tbtnHeight), ForeColor = Color.White, BackColor = Color.FromArgb(70,70,70) };
            btnListThreads.Click += BtnListThreads_Click;
            tabPageTools.Controls.Add(btnListThreads);

            txtToolOutput = new TextBox() { Multiline = true, ReadOnly = true, ScrollBars = ScrollBars.Vertical, Location = new Point(tpadding, tpadding*3+tbtnHeight*2), Size = new Size(1150,500), ForeColor = Color.White, BackColor = Color.FromArgb(30,30,30) };
            tabPageTools.Controls.Add(txtToolOutput);

            WinFormsTimer xinputTimer = new WinFormsTimer() { Interval = 16 };
            xinputTimer.Tick += XinputTimer_Tick;
            xinputTimer.Start();

            WinFormsTimer injectionTimer = new WinFormsTimer() { Interval = 1000 };
            injectionTimer.Tick += InjectionTimer_Tick;
            injectionTimer.Start();

            arrowAnimationTimer = new WinFormsTimer() { Interval = 50 };
            arrowAnimationTimer.Tick += ArrowAnimationTimer_Tick;
            arrowAnimationTimer.Start();

            arrowIndicator = new Label();
            arrowIndicator.Text = "◆";
            arrowIndicator.Font = new Font("Tahoma",12,FontStyle.Bold);
            arrowIndicator.AutoSize = true;
            arrowIndicator.ForeColor = Color.White;
            this.Controls.Add(arrowIndicator);
            arrowIndicator.BringToFront();

            this.KeyPreview = true;
            this.KeyDown += MainForm_KeyDown;
            AttachFocusHandlers(this);
            this.ActiveControl = comboRunningExes;
            UpdateArrowIndicator();
            LogStatus("CHOOCHOO INJECTION ENGINE STARTED");

            LoadRecentsForCombo(comboGame);
            LoadRecentsForCombo(comboTrainer);
            for (int i = 0; i < 4; i++)
                LoadRecentsForCombo(comboAdditional[i]);
            UpdateProfileList();

            chkAutoLaunch.CheckedChanged += (s,e) =>
            {
                SaveSettings();
                LogStatus(chkAutoLaunch.Checked ? "AUTO-LAUNCH ENABLED" : "AUTO-LAUNCH DISABLED");
            };

            RefreshDllList();
            PopulateRunningExes();
            comboRunningExes.SelectedIndexChanged += (s,e) =>
            {
                if (comboRunningExes.SelectedItem is Process proc)
                {
                    gameProcess = proc;
                    LogStatus("Process selected: " + proc.ProcessName + " (PID " + proc.Id + ")");
                }
            };

            {
                string lastProfile = Path.Combine(profilesDir, "last.ini");
                if (File.Exists(lastProfile))
                    LoadProfile(lastProfile);
            }

            XINPUT_STATE state;
            if (XInput.XInputGetState(0, out state) == 0)
                LogStatus("CONTROLLER DETECTED");

            globalHook = new GlobalHook();
            globalHook.KeyPressed += (s,e) => { /* global keyboard hook logic */ };
            globalMouseHook = new GlobalMouseHook();
            globalMouseHook.MouseAction += (s,e) => { /* global mouse hook logic */ };

            this.Resize += MainForm_Resize;
            this.FormClosing += (s,e) =>
            {
                SaveSettings();
                globalHook.Dispose();
                globalMouseHook.Dispose();
            };
            ApplyDarkTheme(this);
            LoadSettings();
            ProcessCommandLineArgs();

            this.Shown += (s,e) =>
            {
                this.Activate();
                if (chkTVMode.Checked && tvModeList != null && tvModeList.Items.Count > 0)
                {
                    tvModeList.SelectedIndices.Clear();
                    tvModeList.SelectedIndices.Add(0);
                    tvModeList.Focus();
                }
            };
        }

        private void BtnRefreshProfiles_Click(object sender, EventArgs e)
        {
            UpdateProfileList();
        }

        private void BtnLoadProfile_Click(object sender, EventArgs e)
        {
            string profileName = comboProfiles.Text.Trim();
            if (string.IsNullOrEmpty(profileName))
            {
                MessageBox.Show("Enter a profile name to load.", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                return;
            }
            string filePath = Path.Combine(profilesDir, profileName + ".ini");
            if (!File.Exists(filePath))
            {
                MessageBox.Show("Profile not found.", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                return;
            }
            LoadProfile(filePath);
        }

        private void BtnSaveProfile_Click(object sender, EventArgs e)
        {
            string profileName = comboProfiles.Text.Trim();
            if (string.IsNullOrEmpty(profileName))
            {
                MessageBox.Show("Enter a profile name to save.", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                return;
            }
            Directory.CreateDirectory(profilesDir);
            string filePath = Path.Combine(profilesDir, profileName + ".ini");
            SaveProfile(filePath);
            UpdateProfileList();
        }

        private void BtnDeleteProfile_Click(object sender, EventArgs e)
        {
            string profileName = comboProfiles.Text.Trim();
            if (string.IsNullOrEmpty(profileName))
            {
                MessageBox.Show("Enter a profile name to delete.", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                return;
            }
            string filePath = Path.Combine(profilesDir, profileName + ".ini");
            if (File.Exists(filePath))
            {
                var result = MessageBox.Show($"Delete profile '{profileName}'?", "Confirm Delete", MessageBoxButtons.YesNo, MessageBoxIcon.Warning);
                if (result == DialogResult.Yes)
                {
                    File.Delete(filePath);
                    UpdateProfileList();
                }
            }
            else
            {
                MessageBox.Show("Profile not found.", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }

        private void BtnLaunch_Click(object sender, EventArgs e)
        {
            if (chkTVMode.Checked)
            {
                Directory.CreateDirectory(profilesDir);
                string lastFile = Path.Combine(profilesDir, "last.ini");
                SaveProfile(lastFile);
                txtStatusLog.Clear();
            }
            Process targetProcess = null;
            if (comboRunningExes.SelectedItem is Process proc)
            {
                try { proc.Refresh(); } catch { }
                if (!proc.HasExited)
                {
                    targetProcess = proc;
                    LogStatus("Using running process: " + proc.ProcessName + " (PID " + proc.Id + ")");
                }
                else
                    LogStatus("Selected process exited. Launching new instance from Game Path.");
            }
            if (targetProcess == null)
                targetProcess = LaunchProcessFromPath(comboGame.Text, "Game");
            if (targetProcess != null)
                gameProcess = targetProcess;
            if (!string.IsNullOrEmpty(comboTrainer.Text))
            {
                int methodIndex = Array.FindIndex(radioTrainerMethods, r => r.Checked);
                Process trainerProc = LaunchTrainerUsingMethod(methodIndex, comboTrainer.Text);
                if (trainerProc != null)
                    LogStatus("Trainer launched.");
            }
            for (int i = 0; i < 4; i++)
            {
                string file = comboAdditional[i].Text.Trim();
                if (string.IsNullOrEmpty(file))
                    continue;
                if (Path.GetExtension(file).ToLowerInvariant() != ".dll")
                    LaunchProcessFromPath(file, $"Additional EXE {i+1}");
            }
        }

        private void BtnFreezeProcess_Click(object sender, EventArgs e)
        {
            if (gameProcess == null)
            {
                LogTool("No target process.");
                return;
            }
            try
            {
                foreach (ProcessThread thread in gameProcess.Threads)
                {
                    IntPtr hThread = NativeMethods.OpenThread(NativeMethods.THREAD_SUSPEND_RESUME, false, (uint)thread.Id);
                    if (hThread != IntPtr.Zero)
                    {
                        uint suspendCount = NativeMethods.SuspendThread(hThread);
                        LogTool($"Suspended thread {thread.Id} (count {suspendCount}).");
                        NativeMethods.CloseHandle(hThread);
                    }
                }
                LogTool("Process frozen.");
            }
            catch (Exception ex)
            {
                LogTool("Freeze error: " + ex.Message);
            }
        }

        private void BtnUnfreezeProcess_Click(object sender, EventArgs e)
        {
            if (gameProcess == null)
            {
                LogTool("No target process.");
                return;
            }
            try
            {
                foreach (ProcessThread thread in gameProcess.Threads)
                {
                    IntPtr hThread = NativeMethods.OpenThread(NativeMethods.THREAD_SUSPEND_RESUME, false, (uint)thread.Id);
                    if (hThread != IntPtr.Zero)
                    {
                        while (NativeMethods.ResumeThread(hThread) > 0) { }
                        LogTool($"Resumed thread {thread.Id}.");
                        NativeMethods.CloseHandle(hThread);
                    }
                }
                LogTool("Process unfrozen.");
            }
            catch (Exception ex)
            {
                LogTool("Unfreeze error: " + ex.Message);
            }
        }

        private void BtnKillProcess_Click(object sender, EventArgs e)
        {
            if (gameProcess == null)
            {
                LogTool("No target process.");
                return;
            }
            try
            {
                gameProcess.Kill();
                LogTool("Process killed.");
            }
            catch (Exception ex)
            {
                LogTool("Kill error: " + ex.Message);
            }
        }

        private void BtnDumpProcess_Click(object sender, EventArgs e)
        {
            if (gameProcess == null)
            {
                LogTool("No target process.");
                return;
            }
            SaveFileDialog sfd = new SaveFileDialog();
            sfd.Filter = "Minidump Files (*.dmp)|*.dmp";
            sfd.FileName = gameProcess.ProcessName + "_" + gameProcess.Id + ".dmp";
            if (sfd.ShowDialog() != DialogResult.OK)
            {
                LogTool("Dump cancelled.");
                return;
            }
            using (FileStream fs = new FileStream(sfd.FileName, FileMode.Create, FileAccess.Write, FileShare.None))
            {
                bool result = NativeMethods.MiniDumpWriteDump(
                    gameProcess.Handle,
                    (uint)gameProcess.Id,
                    fs.SafeFileHandle.DangerousGetHandle(),
                    MINIDUMP_TYPE.MiniDumpWithFullMemory,
                    IntPtr.Zero,
                    IntPtr.Zero,
                    IntPtr.Zero);
                if (result)
                    LogTool("Minidump written to " + sfd.FileName);
                else
                    LogTool("MiniDumpWriteDump failed: " + Marshal.GetLastWin32Error());
            }
        }

        private void BtnListImports_Click(object sender, EventArgs e)
        {
            if (gameProcess == null)
            {
                LogTool("No target process.");
                return;
            }
            try
            {
                string modulePath = gameProcess.MainModule.FileName;
                using (FileStream fs = new FileStream(modulePath, FileMode.Open, FileAccess.Read))
                using (BinaryReader br = new BinaryReader(fs))
                {
                    fs.Seek(0, SeekOrigin.Begin);
                    if (br.ReadUInt16() != 0x5A4D)
                    {
                        LogTool("Not a valid PE file.");
                        return;
                    }
                    fs.Seek(0x3C, SeekOrigin.Begin);
                    int peOffset = br.ReadInt32();
                    fs.Seek(peOffset, SeekOrigin.Begin);
                    if (br.ReadUInt32() != 0x00004550)
                    {
                        LogTool("Invalid PE signature.");
                        return;
                    }
                    br.ReadUInt16();
                    br.ReadUInt16();
                    fs.Seek(12, SeekOrigin.Current);
                    ushort optHeaderSize = br.ReadUInt16();
                    fs.Seek(2, SeekOrigin.Current);
                    long optHeaderStart = fs.Position;
                    fs.Seek(optHeaderStart + 96, SeekOrigin.Begin);
                    uint importRVA = br.ReadUInt32();
                    uint importSize = br.ReadUInt32();
                    if (importRVA == 0)
                    {
                        LogTool("No import table.");
                        return;
                    }
                    fs.Seek(importRVA, SeekOrigin.Begin);
                    List<string> imports = new List<string>();
                    while (true)
                    {
                        uint originalFirstThunk = br.ReadUInt32();
                        uint timeDateStamp = br.ReadUInt32();
                        uint forwarderChain = br.ReadUInt32();
                        uint nameRVA = br.ReadUInt32();
                        uint firstThunk = br.ReadUInt32();
                        if (originalFirstThunk == 0 && nameRVA == 0 && firstThunk == 0)
                            break;
                        long currentPos = fs.Position;
                        fs.Seek(nameRVA, SeekOrigin.Begin);
                        string dllName = "";
                        while (true)
                        {
                            char c = (char)br.ReadByte();
                            if (c == '\0') break;
                            dllName += c;
                        }
                        imports.Add(dllName);
                        fs.Seek(currentPos, SeekOrigin.Begin);
                    }
                    txtToolOutput.Text = "Imports:\r\n" + string.Join("\r\n", imports);
                }
            }
            catch (Exception ex)
            {
                LogTool("List Imports error: " + ex.Message);
            }
        }

        private void BtnListRuntimes_Click(object sender, EventArgs e)
        {
            if (gameProcess == null)
            {
                LogTool("No target process.");
                return;
            }
            try
            {
                List<string> runtimes = new List<string>();
                string[] knownRuntimes = { "clr.dll", "coreclr.dll", "mscoree.dll", "mono.dll", "mrt100.dll" };
                foreach (ProcessModule mod in gameProcess.Modules)
                {
                    foreach (string rt in knownRuntimes)
                    {
                        if (mod.ModuleName.Equals(rt, StringComparison.OrdinalIgnoreCase))
                        {
                            runtimes.Add($"{mod.ModuleName} - {mod.FileVersionInfo.FileVersion}");
                        }
                    }
                }
                txtToolOutput.Text = "Runtimes Used:\r\n" + (runtimes.Count > 0 ? string.Join("\r\n", runtimes) : "None detected.");
            }
            catch (Exception ex)
            {
                LogTool("List Runtimes error: " + ex.Message);
            }
        }

        private void BtnSaveState_Click(object sender, EventArgs e)
        {
            if (gameProcess == null)
            {
                LogTool("No target process.");
                return;
            }
            BtnFreezeProcess_Click(sender, e);
            SaveFileDialog sfd = new SaveFileDialog();
            sfd.Filter = "State Files (*.state)|*.state";
            sfd.FileName = gameProcess.ProcessName + "_" + gameProcess.Id + ".state";
            if (sfd.ShowDialog() != DialogResult.OK)
            {
                LogTool("State save cancelled.");
                BtnUnfreezeProcess_Click(sender, e);
                return;
            }
            try
            {
                List<MemoryRegionDump> regions = new List<MemoryRegionDump>();
                IntPtr addr = IntPtr.Zero;
                MEMORY_BASIC_INFORMATION mbi;
                while (NativeMethods.VirtualQueryEx(gameProcess.Handle, addr, out mbi, (uint)Marshal.SizeOf(typeof(MEMORY_BASIC_INFORMATION))) != IntPtr.Zero)
                {
                    if (mbi.State == 0x1000 && (mbi.Protect & 0x04) != 0)
                    {
                        byte[] buffer = new byte[(int)mbi.RegionSize];
                        UIntPtr bytesRead;
                        if (NativeMethods.ReadProcessMemory(gameProcess.Handle, mbi.BaseAddress, buffer, (uint)buffer.Length, out bytesRead))
                        {
                            regions.Add(new MemoryRegionDump
                            {
                                BaseAddress = mbi.BaseAddress,
                                RegionSize = (uint)buffer.Length,
                                MemoryContents = buffer
                            });
                        }
                    }
                    addr = new IntPtr(mbi.BaseAddress.ToInt64() + mbi.RegionSize.ToInt64());
                }
                using (BinaryWriter bw = new BinaryWriter(File.Open(sfd.FileName, FileMode.Create)))
                {
                    bw.Write(regions.Count);
                    foreach (var region in regions)
                    {
                        bw.Write(region.BaseAddress.ToInt64());
                        bw.Write(region.RegionSize);
                        bw.Write(region.MemoryContents.Length);
                        bw.Write(region.MemoryContents);
                    }
                }
                LogTool("Process state saved to " + sfd.FileName);
            }
            catch (Exception ex)
            {
                LogTool("Save State error: " + ex.Message);
            }
            BtnUnfreezeProcess_Click(sender, e);
        }

        private void BtnLoadState_Click(object sender, EventArgs e)
        {
            if (gameProcess == null)
            {
                LogTool("No target process.");
                return;
            }
            BtnFreezeProcess_Click(sender, e);
            OpenFileDialog ofd = new OpenFileDialog();
            ofd.Filter = "State Files (*.state)|*.state";
            if (ofd.ShowDialog() != DialogResult.OK)
            {
                LogTool("State load cancelled.");
                BtnUnfreezeProcess_Click(sender, e);
                return;
            }
            try
            {
                using (BinaryReader br = new BinaryReader(File.Open(ofd.FileName, FileMode.Open)))
                {
                    int count = br.ReadInt32();
                    for (int i = 0; i < count; i++)
                    {
                        long baseAddrLong = br.ReadInt64();
                        uint regionSize = br.ReadUInt32();
                        int contentLength = br.ReadInt32();
                        byte[] contents = br.ReadBytes(contentLength);
                        IntPtr baseAddress = new IntPtr(baseAddrLong);
                        UIntPtr bytesWritten;
                        bool success = NativeMethods.WriteProcessMemory(gameProcess.Handle, baseAddress, contents, (uint)contents.Length, out bytesWritten);
                        if (!success)
                        {
                            LogTool("WriteProcessMemory failed at " + baseAddress + ": " + Marshal.GetLastWin32Error());
                        }
                    }
                }
                LogTool("Process state loaded from " + ofd.FileName);
            }
            catch (Exception ex)
            {
                LogTool("Load State error: " + ex.Message);
            }
            BtnUnfreezeProcess_Click(sender, e);
        }

        private void BtnListModules_Click(object sender, EventArgs e)
        {
            if (gameProcess == null)
            {
                LogTool("No target process.");
                return;
            }
            try
            {
                string output = "Modules in " + gameProcess.ProcessName + ":\r\n";
                foreach (ProcessModule mod in gameProcess.Modules)
                {
                    output += $"{mod.ModuleName} - Base: 0x{mod.BaseAddress.ToInt64():X}, Size: {mod.ModuleMemorySize} bytes\r\n";
                }
                txtToolOutput.Text = output;
            }
            catch (Exception ex)
            {
                LogTool("List Modules error: " + ex.Message);
            }
        }

        private void BtnListThreads_Click(object sender, EventArgs e)
        {
            if (gameProcess == null)
            {
                LogTool("No target process.");
                return;
            }
            try
            {
                string output = "Threads in " + gameProcess.ProcessName + ":\r\n";
                foreach (ProcessThread t in gameProcess.Threads)
                {
                    output += $"Thread ID: {t.Id}, State: {t.ThreadState}\r\n";
                }
                txtToolOutput.Text = output;
            }
            catch (Exception ex)
            {
                LogTool("List Threads error: " + ex.Message);
            }
        }

        private void InjectionTimer_Tick(object sender, EventArgs e)
        {
            for (int i = 0; i < 4; i++)
            {
                if (chkAdditional[i].Checked)
                    UpdateAdditionalInjection(i);
            }
        }

        private void ApplyDarkTheme(Control control)
        {
            control.BackColor = Color.FromArgb(45,45,48);
            control.ForeColor = Color.White;
            foreach (Control child in control.Controls)
            {
                child.ForeColor = Color.White;
                ApplyDarkTheme(child);
            }
        }

        private void SetupFileBrowserPanel()
        {
            fileBrowserPanel = new Panel();
            fileBrowserPanel.Dock = DockStyle.Fill;
            fileBrowserPanel.BackColor = Color.FromArgb(50,50,50);
            fileBrowserPanel.Padding = new Padding(20);
            fileBrowserPanel.Visible = false;
            fileBrowserLayout = new TableLayoutPanel();
            fileBrowserLayout.Dock = DockStyle.Fill;
            fileBrowserLayout.RowCount = 3;
            fileBrowserLayout.ColumnCount = 1;
            fileBrowserLayout.RowStyles.Add(new RowStyle(SizeType.Absolute, 50));
            fileBrowserLayout.RowStyles.Add(new RowStyle(SizeType.Percent, 100));
            fileBrowserLayout.RowStyles.Add(new RowStyle(SizeType.Absolute, 60));
            fileBrowserPanel.Controls.Add(fileBrowserLayout);
            fileBrowserPathEntry = new TextBox();
            fileBrowserPathEntry.Dock = DockStyle.Fill;
            fileBrowserPathEntry.Font = new Font("Tahoma",14,FontStyle.Bold);
            fileBrowserPathEntry.BackColor = Color.FromArgb(30,30,30);
            fileBrowserPathEntry.ForeColor = Color.White;
            fileBrowserPathEntry.Margin = new Padding(10);
            fileBrowserPathEntry.KeyDown += (s,e) =>
            {
                if (e.KeyCode == Keys.Enter)
                {
                    currentDirectory = fileBrowserPathEntry.Text;
                    RefreshFileBrowserList();
                }
            };
            fileBrowserLayout.Controls.Add(fileBrowserPathEntry,0,0);
            fileBrowserList = new ListView();
            fileBrowserList.Dock = DockStyle.Fill;
            fileBrowserList.View = View.Details;
            fileBrowserList.Font = new Font("Tahoma",14,FontStyle.Bold);
            fileBrowserList.FullRowSelect = true;
            fileBrowserList.GridLines = true;
            fileBrowserList.HeaderStyle = ColumnHeaderStyle.Nonclickable;
            fileBrowserList.Margin = new Padding(10);
            fileBrowserList.Columns.Add("Name",500);
            fileBrowserList.Columns.Add("Type",150);
            fileBrowserList.DoubleClick += (s,e) =>
            {
                if (fileBrowserList.SelectedItems.Count > 0)
                {
                    ListViewItem item = fileBrowserList.SelectedItems[0];
                    if ((string)item.SubItems[1].Text == "FOLDER")
                    {
                        currentDirectory = Path.Combine(currentDirectory, item.Text);
                        RefreshFileBrowserList();
                    }
                    else
                    {
                        currentTargetControl.Text = Path.Combine(currentDirectory, item.Text);
                        fileBrowserPanel.Visible = false;
                    }
                }
            };
            fileBrowserList.KeyDown += (s,e) =>
            {
                if (e.KeyCode == Keys.Enter)
                {
                    if (fileBrowserList.SelectedItems.Count > 0)
                    {
                        ListViewItem item = fileBrowserList.SelectedItems[0];
                        if ((string)item.SubItems[1].Text == "FOLDER")
                        {
                            currentDirectory = Path.Combine(currentDirectory, item.Text);
                            RefreshFileBrowserList();
                        }
                        else
                        {
                            currentTargetControl.Text = Path.Combine(currentDirectory, item.Text);
                            fileBrowserPanel.Visible = false;
                        }
                    }
                }
                else if (e.KeyCode == Keys.Back)
                {
                    var parentDir = Directory.GetParent(currentDirectory);
                    if (parentDir == null)
                        fileBrowserPanel.Visible = false;
                    else
                    {
                        currentDirectory = parentDir.FullName;
                        RefreshFileBrowserList();
                    }
                }
            };
            fileBrowserLayout.Controls.Add(fileBrowserList,0,1);
            fileBrowserButtonPanel = new FlowLayoutPanel();
            fileBrowserButtonPanel.Dock = DockStyle.Fill;
            fileBrowserButtonPanel.FlowDirection = FlowDirection.LeftToRight;
            fileBrowserButtonPanel.Padding = new Padding(10);
            fileBrowserButtonPanel.BackColor = Color.FromArgb(45,45,48);
            btnUp = new Button();
            btnUp.Text = "Up";
            btnUp.Width = 100;
            btnUp.Height = 40;
            btnUp.Font = new Font("Tahoma",12,FontStyle.Bold);
            btnUp.BackColor = Color.FromArgb(70,70,70);
            btnUp.ForeColor = Color.White;
            btnUp.Click += (s,e) =>
            {
                var parentDir = Directory.GetParent(currentDirectory);
                if (parentDir != null)
                {
                    currentDirectory = parentDir.FullName;
                    RefreshFileBrowserList();
                }
            };
            fileBrowserButtonPanel.Controls.Add(btnUp);
            btnRefresh = new Button();
            btnRefresh.Text = "Refresh";
            btnRefresh.Width = 150;
            btnRefresh.Height = 50;
            btnRefresh.Font = new Font("Tahoma",12,FontStyle.Bold);
            btnRefresh.BackColor = Color.FromArgb(70,70,70);
            btnRefresh.ForeColor = Color.White;
            btnRefresh.Click += (s,e) => RefreshFileBrowserList();
            fileBrowserButtonPanel.Controls.Add(btnRefresh);
            btnSelect = new Button() { Text = "Select", Width = 100, Height = 40, Font = new Font("Tahoma",12,FontStyle.Bold), BackColor = Color.FromArgb(70,70,70), ForeColor = Color.White };
            btnSelect.Click += (s,e) =>
            {
                if (fileBrowserList.SelectedItems.Count > 0)
                {
                    ListViewItem item = fileBrowserList.SelectedItems[0];
                    if ((string)item.SubItems[1].Text == "FOLDER") return;
                    currentTargetControl.Text = Path.Combine(currentDirectory, item.Text);
                    fileBrowserPanel.Visible = false;
                }
            };
            fileBrowserButtonPanel.Controls.Add(btnSelect);
            btnCancel = new Button() { Text = "Cancel", Width = 100, Height = 40, Font = new Font("Tahoma",12,FontStyle.Bold), BackColor = Color.FromArgb(70,70,70), ForeColor = Color.White };
            btnCancel.Click += (s,e) => { fileBrowserPanel.Visible = false; };
            fileBrowserButtonPanel.Controls.Add(btnCancel);
            fileBrowserLayout.Controls.Add(fileBrowserButtonPanel,0,2);
            this.Controls.Add(fileBrowserPanel);
            fileBrowserPanel.BringToFront();
        }

        private void RefreshFileBrowserList()
        {
            fileBrowserPathEntry.Text = currentDirectory;
            fileBrowserList.Items.Clear();
            try
            {
                foreach (string dir in Directory.GetDirectories(currentDirectory))
                {
                    ListViewItem item = new ListViewItem(Path.GetFileName(dir));
                    item.SubItems.Add("FOLDER");
                    fileBrowserList.Items.Add(item);
                }
                foreach (string file in Directory.GetFiles(currentDirectory))
                {
                    ListViewItem item = new ListViewItem(Path.GetFileName(file));
                    string ext = Path.GetExtension(file).ToLowerInvariant();
                    string fileType;
                    switch (ext)
                    {
                        case ".txt": fileType = "Text Document"; break;
                        case ".cs": fileType = "C# Source File"; break;
                        case ".exe": fileType = "Executable"; break;
                        case ".dll": fileType = "Dynamic Link Library"; break;
                        case ".png":
                        case ".jpg":
                        case ".jpeg":
                        case ".gif": fileType = "Image File"; break;
                        case ".ini": fileType = "Configuration File"; break;
                        default: fileType = !string.IsNullOrEmpty(ext) ? ext.ToUpper() + " File" : "Unknown File"; break;
                    }
                    item.SubItems.Add(fileType);
                    fileBrowserList.Items.Add(item);
                }
                if (fileBrowserList.Items.Count > 0 && fileBrowserList.SelectedItems.Count == 0)
                    fileBrowserList.Items[0].Selected = true;
            }
            catch (Exception ex)
            {
                ListViewItem errorItem = new ListViewItem("Error: " + ex.Message);
                errorItem.SubItems.Add("");
                fileBrowserList.Items.Add(errorItem);
            }
        }

        private void ShowIntegratedFileBrowser(Control target)
        {
            currentTargetControl = target;
            currentDirectory = Environment.CurrentDirectory;
            RefreshFileBrowserList();
            fileBrowserPanel.Visible = true;
            fileBrowserPanel.BringToFront();
            fileBrowserList.Focus();
        }

        private void IntegratedBrowse(Control target)
        {
            ShowIntegratedFileBrowser(target);
        }

        private void AttachFocusHandlers(Control parent)
        {
            foreach (Control ctrl in parent.Controls)
            {
                ctrl.Enter += (s,e) => UpdateArrowIndicator();
                if (ctrl.Controls.Count > 0)
                    AttachFocusHandlers(ctrl);
            }
        }

        private void UpdateArrowIndicator()
        {
            if (arrowIndicator == null)
                return;
            try
            {
                Control active = GetDeepActiveControl(this);
                if (active is ListView listView && listView.SelectedItems.Count > 0)
                {
                    Rectangle itemBounds = listView.SelectedItems[0].Bounds;
                    Point pt = listView.PointToScreen(itemBounds.Location);
                    pt = this.PointToClient(pt);
                    arrowIndicator.Location = new Point(pt.X - arrowIndicator.Width - 5, pt.Y + (itemBounds.Height - arrowIndicator.Height) / 2);
                }
                else if (active != null)
                {
                    Rectangle bounds = active.Bounds;
                    Point location = active.Parent.PointToScreen(bounds.Location);
                    location = this.PointToClient(location);
                    arrowIndicator.Location = new Point(location.X - arrowIndicator.Width - 5, location.Y + (bounds.Height - arrowIndicator.Height) / 2);
                }
                arrowIndicator.BringToFront();
                arrowIndicator.Visible = true;
            }
            catch 
            { 
                arrowIndicator.Visible = false; 
            }
        }

        private Control GetDeepActiveControl(Control control)
        {
            while (control is ContainerControl container && container.ActiveControl != null)
                control = container.ActiveControl;
            return control;
        }

        private void MainForm_KeyDown(object sender, KeyEventArgs e)
        {
            try
            {
                if (e.KeyCode == Keys.Escape)
                {
                    if (overlayPanel != null && overlayPanel.Visible)
                    {
                        HideOverlay();
                        e.Handled = true;
                        return;
                    }
                    else if (chkTVMode.Checked)
                    {
                        chkTVMode.Checked = false;
                        e.Handled = true;
                        return;
                    }
                    else
                    {
                        this.Close();
                    }
                }
                if (e.KeyCode == Keys.X)
                {
                    SendKeys.Send("{UP}");
                    e.Handled = true;
                }
                if (e.KeyCode == Keys.B)
                {
                    if (overlayPanel != null && overlayPanel.Visible)
                    {
                        HideOverlay();
                        e.Handled = true;
                    }
                    else if (fileBrowserPanel != null && fileBrowserPanel.Visible)
                    {
                        fileBrowserPanel.Visible = false;
                        e.Handled = true;
                    }
                    else if (chkTVMode.Checked)
                    {
                        chkTVMode.Checked = false;
                        e.Handled = true;
                    }
                }
            }
            catch(Exception ex)
            {
                LogStatus("MainForm_KeyDown error: " + ex.Message);
            }
        }

        private void MainForm_Resize(object sender, EventArgs e)
        {
        }

        private void ArrowAnimationTimer_Tick(object sender, EventArgs e)
        {
            arrowAnimationTime += arrowAnimationTimer.Interval / 1000.0;
            arrowAnimationOffset = (int)(arrowAnimationAmplitude * Math.Sin(2 * Math.PI * arrowAnimationTime / arrowAnimationPeriod));
            UpdateArrowIndicator();
        }

        private void UpdateAdditionalInjection(int index)
        {
            string file = comboAdditional[index].Text.Trim();
            if (Path.GetExtension(file).ToLowerInvariant() != ".dll")
            {
                additionalInjectedFile[index] = null;
                chkAdditional[index].Text = "Launch/Inject (Optional)";
                return;
            }
            chkAdditional[index].Text = "Inject (Optional)";
            if (!File.Exists(file))
            {
                if (!validatedDlls.ContainsKey(file))
                {
                    LogStatus($"DLL {Path.GetFileName(file)} NOT FOUND!");
                    validatedDlls[file] = false;
                }
                return;
            }
            if (Environment.Is64BitProcess && !IsDll64Bit(file))
            {
                LogStatus($"DLL {Path.GetFileName(file)} is 32-bit; injection aborted. Please use a 64-bit DLL.");
                validatedDlls[file] = false;
                return;
            }
            if (!validatedDlls.ContainsKey(file) || validatedDlls[file] == false)
            {
                LogStatus($"DLL {Path.GetFileName(file)} found at '{file}' with size {new FileInfo(file).Length} bytes. Beginning injection...");
                InjectDll(file, gameProcess);
                validatedDlls[file] = true;
            }
            RefreshDllList();
        }

        private bool IsDll64Bit(string filePath)
        {
            try
            {
                using (FileStream fs = new FileStream(filePath, FileMode.Open, FileAccess.Read))
                using (BinaryReader br = new BinaryReader(fs))
                {
                    fs.Seek(0x3C, SeekOrigin.Begin);
                    int peOffset = br.ReadInt32();
                    fs.Seek(peOffset, SeekOrigin.Begin);
                    uint peHead = br.ReadUInt32();
                    ushort machine = br.ReadUInt16();
                    return machine == 0x8664;
                }
            }
            catch { return false; }
        }

        private void InjectDll(string dllPath, Process targetProcess)
        {
            try
            {
                IntPtr kernel32 = NativeMethods.GetModuleHandle("kernel32.dll");
                IntPtr loadLibraryAddr = NativeMethods.GetProcAddress(kernel32, "LoadLibraryW");
                if (loadLibraryAddr == IntPtr.Zero)
                {
                    LogStatus("Failed to get address of LoadLibraryW.");
                    return;
                }
                byte[] dllBytes = System.Text.Encoding.Unicode.GetBytes(dllPath + "\0");
                IntPtr allocMemAddress = NativeMethods.VirtualAllocEx(targetProcess.Handle, IntPtr.Zero, (uint)dllBytes.Length, NativeMethods.MEM_COMMIT | NativeMethods.MEM_RESERVE, NativeMethods.PAGE_READWRITE);
                if (allocMemAddress == IntPtr.Zero)
                {
                    LogStatus("Failed to allocate memory in target process.");
                    return;
                }
                UIntPtr bytesWritten;
                bool writeResult = NativeMethods.WriteProcessMemory(targetProcess.Handle, allocMemAddress, dllBytes, (uint)dllBytes.Length, out bytesWritten);
                if (!writeResult || bytesWritten.ToUInt32() != dllBytes.Length)
                {
                    LogStatus("Failed to write DLL path to target process memory.");
                    return;
                }
                uint threadId;
                IntPtr remoteThread = NativeMethods.CreateRemoteThread(targetProcess.Handle, IntPtr.Zero, 0, loadLibraryAddr, allocMemAddress, 0, out threadId);
                if (remoteThread == IntPtr.Zero)
                {
                    LogStatus("Failed to create remote thread for DLL injection.");
                    return;
                }
                NativeMethods.WaitForSingleObject(remoteThread, NativeMethods.INFINITE);
                NativeMethods.CloseHandle(remoteThread);
                NativeMethods.VirtualFreeEx(targetProcess.Handle, allocMemAddress, 0, NativeMethods.MEM_RELEASE);
                LogStatus($"DLL {Path.GetFileName(dllPath)} injected using LoadLibraryW (Remote thread ID {threadId}).");
            }
            catch (Exception ex)
            {
                LogStatus("DLL injection error: " + ex.Message);
            }
        }

        private Process LaunchProcessFromPath(string path, string label)
        {
            if (string.IsNullOrEmpty(path))
                return null;
            if (!File.Exists(path))
            {
                LogStatus($"{label}: FAILED (NOT FOUND)");
                return null;
            }
            string ext = Path.GetExtension(path).ToLowerInvariant();
            if (ext == ".dll")
                return null;

            if (label == "Trainer")
            {
                DateTime start = DateTime.Now;
                Process proc = null;
                while ((DateTime.Now - start).TotalSeconds < 3)
                {
                    try
                    {
                        proc = RawLaunchProcess(path);
                        if (proc != null && !proc.HasExited)
                            break;
                    }
                    catch { }
                    System.Threading.Thread.Sleep(500);
                }
                if (proc == null || proc.HasExited)
                    proc = LaunchTrainerViaCmd(path);
                if (proc != null)
                {
                    LogStatus($"{label}: LAUNCHED (Trainer)");
                    AddRecent(comboTrainer, path);
                    return proc;
                }
                else
                {
                    LogStatus($"{label}: FAILED after fallback.");
                    return null;
                }
            }
            else
            {
                int attempts = 3;
                while (attempts-- > 0)
                {
                    try
                    {
                        ProcessStartInfo psi = new ProcessStartInfo
                        {
                            FileName = path,
                            WorkingDirectory = Path.GetDirectoryName(path) ?? "",
                            UseShellExecute = true,
                            CreateNoWindow = false
                        };
                        Process proc = Process.Start(psi);
                        LogStatus($"{label}: LAUNCHED");
                        if (label == "Game")
                            AddRecent(comboGame, path);
                        return proc;
                    }
                    catch (Exception ex)
                    {
                        LogStatus($"{label}: LAUNCH ATTEMPT FAILED ({ex.Message}). Retrying...");
                        System.Threading.Thread.Sleep(1000);
                    }
                }
                LogStatus($"{label}: FAILED after multiple attempts.");
                return null;
            }
        }

        private Process RawLaunchProcess(string path)
        {
            Win32API.STARTUPINFO si = new Win32API.STARTUPINFO();
            si.cb = Marshal.SizeOf(typeof(Win32API.STARTUPINFO));
            Win32API.PROCESS_INFORMATION pi;
            bool result = Win32API.CreateProcess(path, null, IntPtr.Zero, IntPtr.Zero, false, 0, IntPtr.Zero, Path.GetDirectoryName(path), ref si, out pi);
            if (!result)
            {
                int err = Marshal.GetLastWin32Error();
                throw new Exception("CreateProcess failed, error code " + err);
            }
            if (pi.hThread != IntPtr.Zero)
                NativeMethods.CloseHandle(pi.hThread);
            Process proc = Process.GetProcessById(pi.dwProcessId);
            return proc;
        }

        private Process LaunchTrainerViaCmd(string path)
        {
            try
            {
                ProcessStartInfo psi = new ProcessStartInfo
                {
                    FileName = "cmd.exe",
                    Arguments = $"/C start /B \"\" \"{path}\"",
                    CreateNoWindow = true,
                    UseShellExecute = false
                };
                Process proc = Process.Start(psi);
                return proc;
            }
            catch(Exception ex)
            {
                LogStatus("LaunchTrainerViaCmd failed: " + ex.Message);
                return null;
            }
        }

        private Process LaunchTrainerUsingMethod(int methodIndex, string path)
        {
            if (string.IsNullOrEmpty(path) || !File.Exists(path))
            {
                LogStatus("Trainer: FAILED (NOT FOUND)");
                return null;
            }
            Process proc = null;
            switch (methodIndex)
            {
                case 0:
                    proc = RawLaunchProcess(path);
                    break;
                case 1:
                    proc = LaunchTrainerViaCmd(path);
                    break;
                case 2:
                    proc = LaunchTrainerViaCreateThread(path);
                    break;
                case 3:
                    proc = LaunchTrainerViaRemoteThread(path);
                    break;
                case 4:
                    {
                        ProcessStartInfo psi = new ProcessStartInfo
                        {
                            FileName = path,
                            WorkingDirectory = Path.GetDirectoryName(path),
                            UseShellExecute = true,
                            CreateNoWindow = false
                        };
                        proc = Process.Start(psi);
                    }
                    break;
                case 5:
                    {
                        try { proc = Process.Start(path); } catch (Exception ex) { LogStatus("Raw Process.Start failed: " + ex.Message); }
                    }
                    break;
                default:
                    proc = LaunchTrainerViaCmd(path);
                    break;
            }
            if(proc != null && !proc.HasExited)
                LogStatus($"Trainer: LAUNCHED using method {methodIndex+1}");
            return proc;
        }

        private Process LaunchTrainerViaCreateThread(string path)
        {
            try { return RawLaunchProcess(path); } catch (Exception ex) { LogStatus("CreateThread method failed: " + ex.Message); return null; }
        }

        private Process LaunchTrainerViaRemoteThread(string path)
        {
            try { return RawLaunchProcess(path); } catch (Exception ex) { LogStatus("Remote Thread method failed: " + ex.Message); return null; }
        }

        private void UpdateProfileList()
        {
            comboProfiles.Items.Clear();
            if (Directory.Exists(profilesDir))
            {
                string[] files = Directory.GetFiles(profilesDir, "*.ini");
                foreach (string file in files)
                {
                    string name = Path.GetFileNameWithoutExtension(file);
                    if (name.ToLower() != "last")
                        comboProfiles.Items.Add(name);
                }
            }
        }

        private void SaveProfile(string filePath)
        {
            using (StreamWriter sw = new StreamWriter(filePath))
            {
                sw.WriteLine(comboGame.Text);
                sw.WriteLine(comboTrainer.Text);
                for (int i = 0; i < 4; i++)
                    sw.WriteLine((chkAdditional[i].Checked ? "1" : "0") + "," + comboAdditional[i].Text);
                sw.WriteLine("FULLSCREEN=" + chkFullscreen.Checked);
            }
        }

        private void LoadProfile(string filePath)
        {
            using (StreamReader sr = new StreamReader(filePath))
            {
                comboGame.Text = sr.ReadLine() ?? "";
                comboTrainer.Text = sr.ReadLine() ?? "";
                for (int i = 0; i < 4; i++)
                {
                    string line = sr.ReadLine();
                    if (line != null)
                    {
                        string[] parts = line.Split(new char[] { ',' }, 2);
                        if (parts.Length == 2)
                        {
                            chkAdditional[i].Checked = parts[0] == "1";
                            comboAdditional[i].Text = parts[1];
                        }
                    }
                }
                string settingsLine = sr.ReadLine();
                if (settingsLine != null && settingsLine.StartsWith("FULLSCREEN=", StringComparison.OrdinalIgnoreCase))
                {
                    string val = settingsLine.Substring("FULLSCREEN=".Length).Trim();
                    bool fs;
                    if (bool.TryParse(val, out fs))
                        chkFullscreen.Checked = fs;
                }
            }
        }

        private void LoadRecentsForCombo(ComboBox combo)
        {
            if (combo == null) return;
            if (File.Exists(recentFile))
            {
                string all = File.ReadAllText(recentFile);
                string[] items = all.Split(';');
                combo.Items.Clear();
                foreach (string item in items)
                {
                    string trimmed = item.Trim();
                    if (!string.IsNullOrEmpty(trimmed))
                        combo.Items.Add(trimmed);
                }
            }
        }

        private void AddRecent(ComboBox combo, string text)
        {
            if (string.IsNullOrEmpty(text))
                return;
            if (!combo.Items.Contains(text))
            {
                combo.Items.Insert(0, text);
                while (combo.Items.Count > 10)
                    combo.Items.RemoveAt(combo.Items.Count - 1);
                SaveRecents(combo);
            }
        }

        private void SaveRecents(ComboBox combo)
        {
            string all = "";
            foreach (object item in combo.Items)
                all += (all == "" ? "" : ";") + (item?.ToString() ?? "");
            File.WriteAllText(recentFile, all);
        }

        private void ExportDllList()
        {
            SaveFileDialog sfd = new SaveFileDialog();
            sfd.Filter = "Text Files (*.txt)|*.txt";
            sfd.FileName = "LoadedDlls.txt";
            if (sfd.ShowDialog() == DialogResult.OK)
            {
                using (StreamWriter sw = new StreamWriter(sfd.FileName))
                {
                    sw.WriteLine("Current loaded DLLs/modules:");
                    foreach (object item in listBoxDlls.Items)
                        sw.WriteLine(item?.ToString() ?? "");
                }
                MessageBox.Show("DLL list exported successfully.", "Export", MessageBoxButtons.OK, MessageBoxIcon.Information);
            }
        }

        private void RefreshDllList()
        {
            int topIndex = listBoxDlls.TopIndex;
            List<string> dllList = new List<string>();
            dllList.Add("Current loaded DLLs/modules:");
            try
            {
                ProcessModuleCollection modules = Process.GetCurrentProcess().Modules;
                foreach (ProcessModule module in modules)
                    dllList.Add(module.ModuleName);
            }
            catch (Exception ex)
            {
                dllList.Add("Error: " + ex.Message);
            }
            foreach (var kvp in validatedDlls)
            {
                if (kvp.Value)
                {
                    string dllName = Path.GetFileName(kvp.Key);
                    if (!dllList.Contains(dllName))
                        dllList.Add(dllName + " (Validated)");
                }
            }
            listBoxDlls.BeginUpdate();
            listBoxDlls.Items.Clear();
            foreach (var item in dllList)
                listBoxDlls.Items.Add(item);
            listBoxDlls.EndUpdate();
            try { listBoxDlls.TopIndex = topIndex; } catch { }
        }

        private void XinputTimer_Tick(object sender, EventArgs e)
        {
            XINPUT_STATE state;
            uint result = XInput.XInputGetState(0, out state);
            const short thumbDeadzone = 20000;
            if (tvModePanel.Visible)
            {
                if (state.Gamepad.sThumbLY < -thumbDeadzone)
                {
                    if (!analogDownSent)
                    {
                        SendKeys.Send("{DOWN}");
                        analogDownSent = true;
                    }
                }
                else analogDownSent = false;
                if (state.Gamepad.sThumbLY > thumbDeadzone)
                {
                    if (!analogUpSent)
                    {
                        SendKeys.Send("{UP}");
                        analogUpSent = true;
                    }
                }
                else analogUpSent = false;
                bool aButton = (state.Gamepad.wButtons & XInputConstants.XINPUT_GAMEPAD_A) != 0;
                if (aButton && (prevXInputState.Gamepad.wButtons & XInputConstants.XINPUT_GAMEPAD_A) == 0)
                {
                    if (tvModeList.SelectedItems.Count > 0)
                    {
                        string action = tvModeList.SelectedItems[0].Text;
                        HandleTVModeAction(action);
                    }
                }
                if ((state.Gamepad.wButtons & XInputConstants.XINPUT_GAMEPAD_START) != 0 &&
                    (prevXInputState.Gamepad.wButtons & XInputConstants.XINPUT_GAMEPAD_START) == 0)
                    BtnLaunch_Click(null, EventArgs.Empty);
                prevLeftTrigger = state.Gamepad.bLeftTrigger;
                prevRightTrigger = state.Gamepad.bRightTrigger;
                prevXInputState = state;
                this.Invalidate();
                return;
            }
            if (this.ActiveControl is ComboBox activeCbDropdown && activeCbDropdown.DroppedDown)
            {
                bool dpadDown = (state.Gamepad.wButtons & XInputConstants.XINPUT_GAMEPAD_DPAD_DOWN) != 0;
                bool dpadUp = (state.Gamepad.wButtons & XInputConstants.XINPUT_GAMEPAD_DPAD_UP) != 0;
                int currentIndex = activeCbDropdown.SelectedIndex;
                if (dpadDown && currentIndex < activeCbDropdown.Items.Count - 1)
                    activeCbDropdown.SelectedIndex = currentIndex + 1;
                if (dpadUp && currentIndex > 0)
                    activeCbDropdown.SelectedIndex = currentIndex - 1;
                if ((state.Gamepad.wButtons & XInputConstants.XINPUT_GAMEPAD_DPAD_LEFT) != 0 &&
                    (prevXInputState.Gamepad.wButtons & XInputConstants.XINPUT_GAMEPAD_DPAD_LEFT) == 0)
                    SendKeys.Send("{LEFT}");
                if ((state.Gamepad.wButtons & XInputConstants.XINPUT_GAMEPAD_DPAD_RIGHT) != 0 &&
                    (prevXInputState.Gamepad.wButtons & XInputConstants.XINPUT_GAMEPAD_DPAD_RIGHT) == 0)
                    SendKeys.Send("{RIGHT}");
                bool aButton = (state.Gamepad.wButtons & XInputConstants.XINPUT_GAMEPAD_A) != 0;
                if (aButton && (prevXInputState.Gamepad.wButtons & XInputConstants.XINPUT_GAMEPAD_A) == 0)
                {
                    if (this.ActiveControl is ComboBox activeCb)
                        activeCb.DroppedDown = true;
                    else if (this.ActiveControl is Button btn)
                        btn.PerformClick();
                    else if (this.ActiveControl is CheckBox chk)
                        chk.Checked = !chk.Checked;
                    else
                        SendKeys.Send("{ENTER}");
                }
            }
            bool xButton = (state.Gamepad.wButtons & XInputConstants.XINPUT_GAMEPAD_X) != 0;
            if (xButton && (prevXInputState.Gamepad.wButtons & XInputConstants.XINPUT_GAMEPAD_X) == 0)
                SendKeys.Send("{UP}");
            bool yButton = (state.Gamepad.wButtons & XInputConstants.XINPUT_GAMEPAD_Y) != 0;
            if (yButton && (prevXInputState.Gamepad.wButtons & XInputConstants.XINPUT_GAMEPAD_Y) == 0)
            {
                if (fileBrowserPanel.Visible)
                    RefreshFileBrowserList();
                else if (tvModePanel.Visible)
                    RefreshTVInfo();
            }
            bool bButton = (state.Gamepad.wButtons & XInputConstants.XINPUT_GAMEPAD_B) != 0;
            if (bButton && (prevXInputState.Gamepad.wButtons & XInputConstants.XINPUT_GAMEPAD_B) == 0)
            {
                if (overlayPanel != null && overlayPanel.Visible)
                    HideOverlay();
                else if (fileBrowserPanel != null && fileBrowserPanel.Visible)
                    fileBrowserPanel.Visible = false;
                else if (chkTVMode.Checked)
                    chkTVMode.Checked = false;
            }
            if ((state.Gamepad.wButtons & XInputConstants.XINPUT_GAMEPAD_START) != 0 &&
                (prevXInputState.Gamepad.wButtons & XInputConstants.XINPUT_GAMEPAD_START) == 0)
                BtnLaunch_Click(null, EventArgs.Empty);
            if (state.Gamepad.bLeftTrigger > 30 && prevLeftTrigger <= 30)
                tabControl.SelectedIndex = (tabControl.SelectedIndex - 1 + tabControl.TabCount) % tabControl.TabCount;
            if (state.Gamepad.bRightTrigger > 30 && prevRightTrigger <= 30)
                tabControl.SelectedIndex = (tabControl.SelectedIndex + 1) % tabControl.TabCount;
            if (state.Gamepad.sThumbLY < -thumbDeadzone)
            {
                if (!analogDownSent)
                {
                    SendKeys.Send("{DOWN}");
                    analogDownSent = true;
                }
            }
            else analogDownSent = false;
            if (state.Gamepad.sThumbLY > thumbDeadzone)
            {
                if (!analogUpSent)
                {
                    SendKeys.Send("{UP}");
                    analogUpSent = true;
                }
            }
            else analogUpSent = false;
            if (state.Gamepad.sThumbLX < -thumbDeadzone)
            {
                if (!analogLeftSent)
                {
                    SendKeys.Send("{LEFT}");
                    analogLeftSent = true;
                }
            }
            else analogLeftSent = false;
            if (state.Gamepad.sThumbLX > thumbDeadzone)
            {
                if (!analogRightSent)
                {
                    SendKeys.Send("{RIGHT}");
                    analogRightSent = true;
                }
            }
            else analogRightSent = false;
            prevLeftTrigger = state.Gamepad.bLeftTrigger;
            prevRightTrigger = state.Gamepad.bRightTrigger;
            prevXInputState = state;
            this.Invalidate();
        }

        public void RefreshTVInfo()
        {
            string configInfo = "Game Path (Optional): " + comboGame.Text + Environment.NewLine +
                                "Trainer Path: " + comboTrainer.Text + Environment.NewLine;
            for (int i = 0; i < 4; i++)
            {
                configInfo += $"Additional {i+1} (Optional): {(string.IsNullOrEmpty(comboAdditional[i].Text) ? "[Not Set]" : comboAdditional[i].Text)} - {(chkAdditional[i].Checked ? "Inject" : "Launch/Inject (Optional)")}" + Environment.NewLine;
            }
            configInfo += Environment.NewLine + "Recent Log:" + Environment.NewLine + txtStatusLog.Text;
            if(tvInfoText != null)
                tvInfoText.Text = configInfo;
            else
                LogStatus("tvInfoText is null in RefreshTVInfo");
        }

        private void ToggleTVMode()
        {
            if (chkTVMode.Checked)
            {
                this.FormBorderStyle = FormBorderStyle.None;
                this.WindowState = FormWindowState.Maximized;
                if(mainPanel != null)
                    mainPanel.Visible = false;
                if(tvModePanel != null)
                {
                    tvModePanel.Visible = true;
                    tvModePanel.BringToFront();
                    if (tvModeList != null && tvModeList.Items.Count > 0)
                    {
                        tvModeList.SelectedIndices.Clear();
                        tvModeList.SelectedIndices.Add(0);
                        tvModeList.Focus();
                    }
                }
            }
            else
            {
                HideOverlay();
                if(tvModePanel != null)
                    tvModePanel.Visible = false;
                if(mainPanel != null)
                {
                    mainPanel.Visible = true;
                    mainPanel.BringToFront();
                }
                this.FormBorderStyle = FormBorderStyle.FixedDialog;
                this.WindowState = FormWindowState.Normal;
                this.ClientSize = new Size(1200,750);
            }
        }

        private void HandleTVModeAction(string action)
        {
            switch (action)
            {
                case "Select Running Process":
                    TVSelectRunningProcess();
                    break;
                case "Set Game Path":
                    TVFileBrowser(comboGame);
                    break;
                case "Set Trainer Path":
                    TVFileBrowser(comboTrainer);
                    break;
                case "Set Additional Injection 1":
                    TVFileBrowser(comboAdditional[0]);
                    break;
                case "Set Additional Injection 2":
                    TVFileBrowser(comboAdditional[1]);
                    break;
                case "Set Additional Injection 3":
                    TVFileBrowser(comboAdditional[2]);
                    break;
                case "Set Additional Injection 4":
                    TVFileBrowser(comboAdditional[3]);
                    break;
                case "Configure DLL Injections":
                    TVConfigureDLLInjections();
                    break;
                case "Manage Profiles":
                    TVManageProfiles();
                    break;
                case "Launch Application":
                    BtnLaunch_Click(null, EventArgs.Empty);
                    break;
                case "View Console Output":
                    TVViewConsoleOutput();
                    break;
                case "Exit TV Mode":
                    chkTVMode.Checked = false;
                    break;
                default:
                    break;
            }
            RefreshTVInfo();
        }

        private void TVSelectRunningProcess()
        {
            try
            {
                Panel panel = new Panel();
                panel.BackColor = Color.FromArgb(45,45,48);
                panel.Dock = DockStyle.Fill;
                panel.Padding = new Padding(20);
                ListView processList = new ListView();
                processList.Dock = DockStyle.Fill;
                processList.View = View.Details;
                processList.FullRowSelect = true;
                processList.GridLines = true;
                processList.HeaderStyle = ColumnHeaderStyle.None;
                processList.Font = new Font(tvFont.FontFamily,18,FontStyle.Bold);
                processList.ForeColor = Color.White;
                processList.BackColor = Color.FromArgb(30,30,30);
                processList.Margin = new Padding(10);
                processList.Columns.Add("Process",-2,HorizontalAlignment.Center);
                processList.Columns.Add("PID",-2,HorizontalAlignment.Center);
                Process[] procs = ProcessHelper.GetProcesses();
                if (procs == null || procs.Length == 0)
                {
                    MessageBox.Show("No processes found.", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return;
                }
                foreach (Process p in procs)
                {
                    try
                    {
                        ListViewItem lvi = new ListViewItem(p.ProcessName);
                        lvi.SubItems.Add(p.Id.ToString());
                        processList.Items.Add(lvi);
                    }
                    catch { }
                }
                if (processList.Items.Count > 0)
                    processList.SelectedIndices.Add(0);
                processList.KeyDown += (s,e) =>
                {
                    try 
                    {
                        if (e.KeyCode == Keys.Enter && processList.SelectedItems.Count > 0)
                        {
                            string sel = processList.SelectedItems[0].SubItems[0].Text;
                            foreach (Process p in procs)
                            {
                                if (p.ProcessName == sel)
                                {
                                    gameProcess = p;
                                    LogStatus("Process selected: " + p.ProcessName + " (PID " + p.Id + ")");
                                    break;
                                }
                            }
                            HideOverlay();
                            e.Handled = true;
                        }
                    }
                    catch (Exception ex)
                    {
                        LogStatus("Error in process list: " + ex.Message);
                    }
                };
                panel.Controls.Add(processList);
                ShowOverlay(panel);
            }
            catch(Exception ex)
            {
                LogStatus("TVSelectRunningProcess error: " + ex.Message);
            }
        }

        private void TVFileBrowser(Control target)
        {
            ShowIntegratedFileBrowser(target);
        }

        private void TVFileBrowserForTextBox(TextBox target)
        {
            ShowIntegratedFileBrowser(target);
        }

        private void TVConfigureDLLInjections()
        {
            try
            {
                Panel panel = new Panel();
                panel.BackColor = Color.FromArgb(45,45,48);
                panel.Dock = DockStyle.Fill;
                TableLayoutPanel tbl = new TableLayoutPanel();
                tbl.Dock = DockStyle.Fill;
                tbl.RowCount = 4;
                tbl.ColumnCount = 3;
                tbl.ColumnStyles.Add(new ColumnStyle(SizeType.Percent,30));
                tbl.ColumnStyles.Add(new ColumnStyle(SizeType.Percent,50));
                tbl.ColumnStyles.Add(new ColumnStyle(SizeType.Percent,20));
                for (int i = 0; i < 4; i++)
                {
                    Label lbl = new Label() { Text = "Additional Injection " + (i+1) + " (Optional)", Dock = DockStyle.Fill, ForeColor = Color.White, Padding = new Padding(5) };
                    TextBox tb = new TextBox() { Text = comboAdditional[i].Text, Dock = DockStyle.Fill, Font = new Font(tvFont.FontFamily,16,FontStyle.Bold), Margin = new Padding(5) };
                    CheckBox chk = new CheckBox() { Checked = chkAdditional[i].Checked, Dock = DockStyle.Fill, Font = new Font(tvFont.FontFamily,16,FontStyle.Bold), ForeColor = Color.White, Margin = new Padding(5) };
                    int index = i;
                    chk.CheckedChanged += (s,e) => { chkAdditional[index].Checked = chk.Checked; };
                    Button btnBrowse = new Button() { Text = "Browse", Dock = DockStyle.Fill, Font = tvFont, Margin = new Padding(5), BackColor = Color.FromArgb(70,70,70), ForeColor = Color.White };
                    btnBrowse.Click += (s,e) => { TVFileBrowserForTextBox(tb); };
                    tbl.Controls.Add(lbl, 0, i);
                    tbl.Controls.Add(tb, 1, i);
                    Panel pnl = new Panel() { Dock = DockStyle.Fill, Margin = new Padding(5) };
                    pnl.Controls.Add(chk);
                    pnl.Controls.Add(btnBrowse);
                    btnBrowse.Location = new Point(150,0);
                    tbl.Controls.Add(pnl, 2, i);
                    tb.TextChanged += (s,e) => { comboAdditional[index].Text = tb.Text; };
                }
                Button btnOk = new Button() { Text = "OK", Dock = DockStyle.Bottom, Height = 50, Font = tvFont, Margin = new Padding(5), BackColor = Color.FromArgb(70,70,70), ForeColor = Color.White };
                btnOk.Click += (s,e) => { HideOverlay(); };
                panel.Controls.Add(tbl);
                panel.Controls.Add(btnOk);
                ShowOverlay(panel);
            }
            catch(Exception ex)
            {
                LogStatus("TVConfigureDLLInjections error: " + ex.Message);
            }
        }

        private void TVManageProfiles()
        {
            try
            {
                Panel panel = new Panel();
                panel.BackColor = Color.FromArgb(45,45,48);
                panel.Dock = DockStyle.Fill;
                TableLayoutPanel tbl = new TableLayoutPanel();
                tbl.Dock = DockStyle.Fill;
                tbl.RowCount = 2;
                tbl.RowStyles.Add(new RowStyle(SizeType.Percent, 80));
                tbl.RowStyles.Add(new RowStyle(SizeType.Percent, 20));
                panel.Controls.Add(tbl);

                ListView lb = new ListView();
                lb.Dock = DockStyle.Fill;
                lb.View = View.Details;
                lb.FullRowSelect = true;
                lb.GridLines = true;
                lb.HeaderStyle = ColumnHeaderStyle.None;
                lb.Font = new Font(tvFont.FontFamily,18,FontStyle.Bold);
                lb.ForeColor = Color.White;
                lb.BackColor = Color.FromArgb(30,30,30);
                lb.Margin = new Padding(10);
                lb.Columns.Add("Profile",-2,HorizontalAlignment.Center);
                if (Directory.Exists(profilesDir))
                {
                    string[] files = Directory.GetFiles(profilesDir, "*.ini");
                    foreach (string file in files)
                    {
                        string name = Path.GetFileNameWithoutExtension(file);
                        if (name.ToLower() != "last")
                            lb.Items.Add(new ListViewItem(name));
                    }
                }
                if (lb.Items.Count > 0)
                    lb.SelectedIndices.Add(0);
                tbl.Controls.Add(lb, 0, 0);

                FlowLayoutPanel panelButtons = new FlowLayoutPanel();
                panelButtons.Dock = DockStyle.Fill;
                panelButtons.Padding = new Padding(10);
                Button btnLoad = new Button() { Text = "Load", Width = 150, Height = 50, Font = tvFont, Margin = new Padding(5), BackColor = Color.FromArgb(70,70,70), ForeColor = Color.White };
                btnLoad.Click += (s,e) =>
                {
                    if (lb.SelectedItems.Count > 0)
                    {
                        string profileName = lb.SelectedItems[0].Text;
                        string filePath = Path.Combine(profilesDir, profileName + ".ini");
                        if (File.Exists(filePath))
                        {
                            LoadProfile(filePath);
                            LogStatus("Profile loaded: " + profileName);
                        }
                    }
                };
                Button btnSave = new Button() { Text = "Save", Width = 150, Height = 50, Font = tvFont, Margin = new Padding(5), BackColor = Color.FromArgb(70,70,70), ForeColor = Color.White };
                btnSave.Click += (s,e) =>
                {
                    string profileName = comboProfiles.Text.Trim();
                    if (!string.IsNullOrEmpty(profileName))
                    {
                        string filePath = Path.Combine(profilesDir, profileName + ".ini");
                        SaveProfile(filePath);
                        LogStatus("Profile saved: " + profileName);
                        lb.Items.Clear();
                        if (Directory.Exists(profilesDir))
                        {
                            string[] files = Directory.GetFiles(profilesDir, "*.ini");
                            foreach (string file in files)
                            {
                                string name = Path.GetFileNameWithoutExtension(file);
                                if (name.ToLower() != "last")
                                    lb.Items.Add(new ListViewItem(name));
                            }
                        }
                    }
                };
                Button btnDelete = new Button() { Text = "Delete", Width = 150, Height = 50, Font = tvFont, Margin = new Padding(5), BackColor = Color.FromArgb(70,70,70), ForeColor = Color.White };
                btnDelete.Click += (s,e) =>
                {
                    if (lb.SelectedItems.Count > 0)
                    {
                        string profileName = lb.SelectedItems[0].Text;
                        string filePath = Path.Combine(profilesDir, profileName + ".ini");
                        if (File.Exists(filePath))
                        {
                            File.Delete(filePath);
                            LogStatus("Profile deleted: " + profileName);
                            lb.Items.Remove(lb.SelectedItems[0]);
                        }
                    }
                };
                panelButtons.Controls.Add(btnLoad);
                panelButtons.Controls.Add(btnSave);
                panelButtons.Controls.Add(btnDelete);
                tbl.Controls.Add(panelButtons, 0, 1);

                ShowOverlay(panel);
            }
            catch(Exception ex)
            {
                LogStatus("TVManageProfiles error: " + ex.Message);
            }
        }

        private void TVViewConsoleOutput()
        {
            try
            {
                Panel panel = new Panel();
                panel.BackColor = Color.FromArgb(45,45,48);
                panel.Dock = DockStyle.Fill;
                TextBox tb = new TextBox();
                tb.Multiline = true;
                tb.ReadOnly = true;
                tb.ScrollBars = ScrollBars.Vertical;
                tb.Dock = DockStyle.Fill;
                tb.Font = tvFont;
                tb.BackColor = Color.FromArgb(30,30,30);
                tb.ForeColor = Color.White;
                tb.Margin = new Padding(10);
                tb.Text = txtStatusLog.Text;
                panel.Controls.Add(tb);
                ShowOverlay(panel);
            }
            catch(Exception ex)
            {
                LogStatus("TVViewConsoleOutput error: " + ex.Message);
            }
        }

        private void SetupTVModePanel()
        {
            tvModePanel = new Panel();
            tvModePanel.Dock = DockStyle.Fill;
            tvModePanel.BackColor = Color.FromArgb(45,45,48);
            tvModePanel.Visible = false;
            this.Controls.Add(tvModePanel);

            TableLayoutPanel tvLayout = new TableLayoutPanel();
            tvLayout.Dock = DockStyle.Fill;
            tvLayout.RowCount = 3;
            tvLayout.ColumnCount = 1;
            tvLayout.RowStyles.Add(new RowStyle(SizeType.Percent, 15));
            tvLayout.RowStyles.Add(new RowStyle(SizeType.Percent, 70));
            tvLayout.RowStyles.Add(new RowStyle(SizeType.Percent, 15));
            tvModePanel.Controls.Add(tvLayout);

            Panel tvHeaderPanel = new Panel();
            tvHeaderPanel.Dock = DockStyle.Fill;
            tvHeaderPanel.BackColor = Color.FromArgb(45,45,48);
            Button btnTVLaunch = new Button();
            btnTVLaunch.Text = "Launch";
            btnTVLaunch.Font = tvFont;
            btnTVLaunch.Dock = DockStyle.Left;
            btnTVLaunch.Width = 150;
            btnTVLaunch.BackColor = Color.FromArgb(70,70,70);
            btnTVLaunch.ForeColor = Color.White;
            btnTVLaunch.Click += (s,e) => BtnLaunch_Click(null, EventArgs.Empty);
            Label lblTVHeader = new Label();
            lblTVHeader.Text = "CHOOCHOO LOADER - TV MODE";
            lblTVHeader.Font = tvFont;
            lblTVHeader.ForeColor = Color.White;
            lblTVHeader.Dock = DockStyle.Fill;
            lblTVHeader.TextAlign = ContentAlignment.MiddleCenter;
            tvHeaderPanel.Controls.Add(btnTVLaunch);
            tvHeaderPanel.Controls.Add(lblTVHeader);
            tvLayout.Controls.Add(tvHeaderPanel, 0, 0);

            Panel tvMenuPanel = new Panel();
            tvMenuPanel.Dock = DockStyle.Fill;
            tvMenuPanel.BackColor = Color.FromArgb(30,30,30);
            tvModeList = new ListView();
            tvModeList.Dock = DockStyle.Fill;
            tvModeList.View = View.List;
            tvModeList.Font = new Font(tvFont.FontFamily, 22, FontStyle.Bold);
            tvModeList.ForeColor = Color.White;
            tvModeList.BackColor = Color.FromArgb(30,30,30);
            string[] menuItems = new string[]
            {
                "Select Running Process",
                "Set Game Path",
                "Set Trainer Path",
                "Set Additional Injection 1",
                "Set Additional Injection 2",
                "Set Additional Injection 3",
                "Set Additional Injection 4",
                "Configure DLL Injections",
                "Manage Profiles",
                "Launch Application",
                "View Console Output",
                "Exit TV Mode"
            };
            tvModeList.Items.Clear();
            foreach (string item in menuItems)
                tvModeList.Items.Add(new ListViewItem(item));
            if (tvModeList.Items.Count > 0 && tvModeList.SelectedIndices.Count == 0)
                tvModeList.SelectedIndices.Add(0);
            tvModeList.KeyDown += (s,e) =>
            {
                try 
                {
                    if (e.KeyCode == Keys.Enter)
                    {
                        if (tvModeList.SelectedItems.Count > 0)
                        {
                            string action = tvModeList.SelectedItems[0].Text;
                            HandleTVModeAction(action);
                        }
                        e.Handled = true;
                    }
                    else if (e.KeyCode == Keys.Escape || e.KeyCode == Keys.B)
                    {
                        chkTVMode.Checked = false;
                        e.Handled = true;
                    }
                }
                catch (Exception ex)
                {
                    LogStatus("TVMode list error: " + ex.Message);
                }
            };
            tvMenuPanel.Controls.Add(tvModeList);
            tvLayout.Controls.Add(tvMenuPanel, 0, 1);

            Panel tvFooterPanel = new Panel();
            tvFooterPanel.Dock = DockStyle.Fill;
            tvFooterPanel.BackColor = Color.FromArgb(50,50,50);
            tvInfoText = new TextBox();
            tvInfoText.Dock = DockStyle.Fill;
            tvInfoText.Multiline = true;
            tvInfoText.ReadOnly = true;
            tvInfoText.Font = tvFont;
            tvInfoText.BackColor = Color.FromArgb(30,30,30);
            tvInfoText.ForeColor = Color.White;
            tvFooterPanel.Controls.Add(tvInfoText);
            tvLayout.Controls.Add(tvFooterPanel, 0, 2);
        }

        private void SaveSettings()
        {
            try {
                using (StreamWriter sw = new StreamWriter(settingsFile))
                {
                    sw.WriteLine(chkFullscreen.Checked);
                    sw.WriteLine(chkTVMode.Checked);
                    sw.WriteLine(chkAutoLaunch.Checked);
                }
            }
            catch (Exception ex)
            {
                LogStatus("Error saving settings: " + ex.Message);
            }
        }

        private void LoadSettings()
        {
            try {
                if (File.Exists(settingsFile))
                {
                    using (StreamReader sr = new StreamReader(settingsFile))
                    {
                        bool fs, tv, auto;
                        if (bool.TryParse(sr.ReadLine(), out fs))
                            chkFullscreen.Checked = fs;
                        if (bool.TryParse(sr.ReadLine(), out tv))
                            chkTVMode.Checked = tv;
                        if (bool.TryParse(sr.ReadLine(), out auto))
                            chkAutoLaunch.Checked = auto;
                    }
                }
            }
            catch (Exception ex)
            {
                LogStatus("Error loading settings: " + ex.Message);
            }
        }

        private void ShowOverlay(Control control)
        {
            if (overlayPanel != null)
            {
                overlayPanel.Controls.Clear();
                control.Dock = DockStyle.Fill;
                overlayPanel.Controls.Add(control);
                overlayPanel.Visible = true;
                overlayPanel.BringToFront();
                control.Focus();
            }
        }

        private void HideOverlay()
        {
            if (overlayPanel != null)
            {
                overlayPanel.Visible = false;
                overlayPanel.Controls.Clear();
            }
            if (tvModePanel != null && tvModePanel.Visible)
            {
                if (tvModeList != null && tvModeList.Items.Count > 0)
                {
                    tvModeList.SelectedIndices.Clear();
                    tvModeList.SelectedIndices.Add(0);
                }
                tvModePanel.Focus();
            }
            else if (mainPanel != null)
            {
                mainPanel.Focus();
            }
        }

        private void LogStatus(string message)
        {
            txtStatusLog.AppendText(message.ToUpper() + Environment.NewLine);
        }

        private void LogTool(string message)
        {
            txtToolOutput.AppendText(message + Environment.NewLine);
        }

        private void PopulateRunningExes()
        {
            comboRunningExes.Items.Clear();
            LogStatus("Scanning running processes...");
            Process[] procs = ProcessHelper.GetProcesses();
            foreach (Process p in procs)
            {
                try
                {
                    comboRunningExes.Items.Add(p);
                    LogStatus($"Detected: {p.ProcessName} (PID {p.Id})");
                }
                catch (Exception ex)
                {
                    LogStatus("Error: " + ex.Message);
                }
            }
            if (comboRunningExes.Items.Count == 0)
            {
                foreach (Process p in Process.GetProcesses())
                {
                    try
                    {
                        if (!string.IsNullOrEmpty(p.MainWindowTitle))
                        {
                            comboRunningExes.Items.Add(p);
                            LogStatus("Detected (fallback): " + p.ProcessName);
                        }
                    }
                    catch { }
                }
            }
            if (comboRunningExes.Items.Count > 0)
                comboRunningExes.SelectedIndex = 0;
        }

        private void ProcessCommandLineArgs()
        {
            string[] args = Environment.GetCommandLineArgs();
            for (int i = 1; i < args.Length; i++)
            {
                string arg = args[i].ToLower();
                if (arg == "-p" || arg == "--profile")
                {
                    if (i + 1 < args.Length)
                    {
                        string profileName = args[i+1];
                        comboProfiles.Text = profileName;
                        string filePath = Path.Combine(profilesDir, profileName + ".ini");
                        if (File.Exists(filePath))
                            LoadProfile(filePath);
                        i++;
                    }
                }
                else if (arg == "-autolaunch")
                {
                    chkAutoLaunch.Checked = true;
                }
                else if (arg == "-dllinject")
                {
                    int j = i+1;
                    int index = 0;
                    while (j < args.Length && !args[j].StartsWith("-") && index < 4)
                    {
                        comboAdditional[index].Text = args[j];
                        chkAdditional[index].Checked = true;
                        index++;
                        j++;
                    }
                    i = j - 1;
                }
            }
            if (chkAutoLaunch.Checked)
            {
                var launchTimer = new WinFormsTimer { Interval = 2000 };
                launchTimer.Tick += (s,e) =>
                {
                    launchTimer.Stop();
                    BtnLaunch_Click(null, EventArgs.Empty);
                };
                launchTimer.Start();
            }
        }
    }

    public class MemoryRegionDump
    {
        public IntPtr BaseAddress { get; set; }
        public uint RegionSize { get; set; }
        public byte[] MemoryContents { get; set; }
    }

    public static class Program
    {
        [STAThread]
        public static void Main()
        {
            try {
                Application.EnableVisualStyles();
                Application.SetCompatibleTextRenderingDefault(false);
                Application.Run(new MainForm());
            }
            catch (Exception ex) {
                MessageBox.Show("Unhandled exception: " + ex.Message, "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }
    }
}
"""
    }

    for filename, content in files.items():
        write_file(filename, content)

    print("All project files generated. Now building...\n")
    build_command = ["dotnet", "build", "ChooChooApp.csproj", "-c", "Release"]
    try:
        proc = subprocess.run(build_command, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        print("Build output:\n")
        print(proc.stdout)
        print("Build completed successfully.")
    except subprocess.CalledProcessError as e:
        print("Build failed!")
        print("Stdout:\n", e.stdout)
        print("Stderr:\n", e.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()
